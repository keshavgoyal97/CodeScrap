{"Given an integer A, how many structurally unique BST\u2019s (binary search trees) exist that can store values 1\u2026A? Input Format: The first and the only argument of input contains the integer, A. Output Format: Return an integer, representing the answer asked in problem statement. Constraints: 1 <= A <= 18 Example: Input 1: A = 3 Output 1: 5 Explanation 1: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3": "class Solution:\n    # @param A : integer\n    # @return an integer\n    def numTrees(self, A):\n        n=A\n        dp=[0] * (n + 1)\n        dp[0],dp[1] = 1, 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[i-j]*dp[j-1]\n        return dp[n]\n\n\n\n", "Given two strings A and B, find the minimum number of steps required to convert A to B. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: * Insert a character * Delete a character * Replace a character Input Format: The first argument of input contains a string, A. The second argument of input contains a string, B. Output Format: Return an integer, representing the minimum number of steps required. Constraints: 1 <= length(A), length(B) <= 450 Examples: Input 1: A = \"abad\" B = \"abac\" Output 1: 1 Explanation 1: Operation 1: Replace d with c. Input 2: A = \"Anshuman\" B = \"Antihuman\" Output 2: 2 Explanation 2: => Operation 1: Replace s with t. => Operation 2: Insert i.": "class Solution:\n    # @param A : string\n    # @param B : string\n    # @return an integer\n    def minDistance(self, A, B):\n        ans=self.solve(A,B,len(A),len(B))\n        return ans\n\n\n    # def solve(self, A, B, n, m):\n    #     if (n==0):\n    #         return m\n    #     if (m==0):\n    #         return n\n        \n    #     if (A[n-1]==B[m-1]):\n    #         return self.solve(A,B,n-1,m-1)\n    #     else:\n    #         return 1+min(self.solve(A,B,n-1,m-1), self.solve(A,B,n-1,m), self.solve(A,B,n,m-1))\n    \n    def solve(self, A, B, n, m):\n        t=[[0]*(m+1) for _ in range (n+1)]\n\n        for i in range (1,n+1):\n            t[i][0]=i\n        for i in range (1,m+1):\n            t[0][i]=i\n        \n        for i in range (1,n+1):\n            for j in range (1,m+1):\n                if (A[i-1]==B[j-1]):\n                    t[i][j]=t[i-1][j-1]\n                else:\n                    t[i][j]=1+min(t[i-1][j-1], t[i-1][j], t[i][j-1])\n        return t[n][m]\n\n\n", "Given an array of non-negative integers, A, of length N, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Return the minimum number of jumps required to reach the last index. If it is not possible to reach the last index, return -1. Problem Constraints 1 <= N <= 106 0 <= A[i] <= 50000 Input Format The first and the only argument contains an integer array, A. Output Format Return an integer, representing the answer as described in the problem statement. Example Input Input 1:A = [2, 1, 1] Input 2:A = [2, 3, 1, 1, 4] Example Output Output 1:1 Output 1:2 Example Explanation Explanation 1:The shortest way to reach index 2 is Index 0 -> Index 2 that requires only 1 jump. Explanation 2:The shortest way to reach index 4 is Index 0 -> Index 1 -> Index 4 that requires 2 jumps.": "class Solution:\n\t# @param A : list of integers\n\t# @return an integer\n\tdef jump(self, A):\n\t    \n\t    last = len(A) - 1\n\t    jumps = 0\n\t    reachable = 0      # reachable with current number of jumps \n\t    next_reachable = 0 # reachable with one additionnal jump\n\t    for i, x in enumerate(A):\n\t        \n\t        if reachable >= last:\n\t            break \n\t        \n\t        if reachable < i:\n\t            reachable = next_reachable\n\t            jumps += 1\n\t            if reachable < i:\n\t                return -1\n\t        next_reachable = max(next_reachable, i+x)\n\t    \n\t    return jumps\n\t            \n\n\t    \n\t        \n\t        \n\t        \n\n\n\n", "Given a 2D integer array A of size M x N, you need to find a path from top left to bottom right which minimizes the sum of all numbers along its path. NOTE: You can only move either down or right at any point in time. Input Format First and only argument is an 2D integer array A of size M x N. Output Format Return a single integer denoting the minimum sum of a path from cell (1, 1) to cell (M, N). Example Input Input 1: A = [ [1, 3, 2] [4, 3, 1] [5, 6, 1] ] Example Output Output 1: 8 Example Explanation Explanation 1: The path is 1 -> 3 -> 2 -> 1 -> 1 So ( 1 + 3 + 2 + 1 + 1) = 8": "class Solution:\n    # @param A : list of list of integers\n    # @return an integer\n    def minPathSum(self, A):\n        n = len(A)\n        m = len(A[0])\n        dp = [[0 for _ in range(m)] for _ in range(n)]\n        dp[n-1][m-1] = A[n-1][m-1]\n        for i in range(n-1,-1,-1):\n            for j in range(m-1,-1,-1):\n                if j == m-1:\n                    if i != n-1:\n                        dp[i][j] = A[i][j] + dp[i+1][j]\n                elif i==n-1:\n                    dp[i][j] = A[i][j] + dp[i][j+1]\n                else:    \n                    dp[i][j] = A[i][j] + min(dp[i][j+1], dp[i+1][j])\n        return dp[0][0]\n\n\n\n", "Given a string A, partition A such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of A. Problem Constraints 1 <= length(A) <= 501 Input Format The first and the only argument contains the string A. Output Format Return an integer, representing the minimum cuts needed. Example Input Input 1: A = \"aba\" Input 2: A = \"aab\" Example Output Output 1: 0 Output 2: 1 Example Explanation Explanation 1: \"aba\" is already a palindrome, so no cuts are needed. Explanation 2: Return 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.": "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit(100000)\nclass Solution:\n    # @param A : string\n    # @return an integer\n    @lru_cache(100000)\n    def minCut(self, s):\n        return 0 if s[::-1] == s else min(1 + self.minCut(s[i:]) for i in range(1, len(s)) if s[:i][::-1] == s[:i])\n            \n\n\n\n", "Implement wildcard pattern matching with support for '?' and '*' for strings A and B. * '?' : Matches any single character. * '*' : Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Problem Constraints 1 <= |A|, |B| <= 9e4 Input Format The first argument of input contains a string A. The second argument of input contains a string B. Output Format Return 0 or 1: => 0 : If the patterns do not match. => 1 : If the patterns match. Example Input Input 1: A = \"aa\" B = \"a\" Input 2: A = \"aa\" B = \"aa\" Input 3: A = \"aaa\" B = \"aa\" Input 4: A = \"aa\" B = \"*\" Input 5: A = \"aa\" B = \"a*\" Input 6: A = \"ab\" B = \"?*\" Input 7: A = \"aab\" B = \"c*a*b\" Example Output Output 1:0 Output 2:1 Output 3:0 Output 4:1 Output 5:1 Output 6:1 Output 7:0": "class Solution:\r\n    # @param s : string\r\n    # @param p : string\r\n    # @return an integer\r\n    def isMatch(self, s, p):\r\n        if len(p) - p.count('*') > len(s):\r\n            return 0\r\n        DP = [True] + [False]*len(s)\r\n        for c in p:\r\n            if c == '*':\r\n                for n in range(1, len(s)+1):\r\n                    DP[n] = DP[n-1] or DP[n]\r\n            else:\r\n                for n in range(len(s)-1, -1, -1):\r\n                    DP[n+1] = DP[n] and (c == s[n] or c == '?')\r\n            DP[0] = DP[0] and c == '*'\r\n        return 1 if DP[-1] else 0", "Given a binary tree T, find the maximum path sum. The path may start and end at any node in the tree. Problem Constraints 1 <= Number of Nodes <= 7e4 -1000 <= Value of Node in T <= 1000 Input Format The first and the only argument contains a pointer to the root of T, A. Output Format Return an integer representing the maximum sum path. Example Input Input 1: 1 / \\ 2 3 Input 2: 20 / \\ -10 20 / \\ -10 -50 Example Output Output 1: 6 Output 2: 40 Example Explanation Explanation 1: The path with maximum sum is: 2 -> 1 -> 3 Explanation 2: The path with maximum sum is: 20 -> 20": "# Definition for a  binary tree node\n# class TreeNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.left = None\n#        self.right = None\n\nclass Solution:\n    # @param A : root node of tree\n    # @return an integer\n    def maxPathSum(self, A):\n        max_path_sum = float(\"-inf\")\n        \n        def get_max_sum(root, memo):\n            if root in memo:\n                return memo[root]\n                \n            nonlocal max_path_sum\n            if not root:\n                return 0\n            \n            left_sum = max(get_max_sum(root.left, memo), 0)\n            right_sum = max(get_max_sum(root.right, memo), 0)\n            \n            current_max_sum = root.val + left_sum + right_sum\n            max_path_sum = max(max_path_sum, current_max_sum)\n            \n            memo[root] = root.val + max(left_sum, right_sum) \n            return memo[root]\n        \n        get_max_sum(A, {})\n        return max_path_sum\n\n\n", "Say you have an array, A, for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Return the maximum possible profit. Problem Constraints 0 <= len(A) <= 7e5 1 <= A[i] <= 1e7 Input Format The first and the only argument is an array of integers, A. Output Format Return an integer, representing the maximum possible profit. Example Input Input 1: A = [1, 2] Input 2: A = [1, 4, 5, 2, 4] Example Output Output 1: 1 Output 2: 4 Example Explanation Explanation 1: Buy the stock on day 0, and sell it on day 1. Explanation 2: Buy the stock on day 0, and sell it on day 2.": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def maxProfit(self, A):\n        n = len(A)\n        max_profit = 0\n        dp = [0] * n\n        for i in range(n-2, -1, -1):\n            dp[i] = max(A[i+1], dp[i+1])\n            \n        for i in range(n-1):\n            max_profit = max(max_profit, dp[i] - A[i])\n                \n        return max_profit\n\n\n", "Say you have an array, A, for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most 2 transactions. Return the maximum possible profit. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Problem Constraints 1 <= length(A) <= 7e5 1 <= A[i] <= 1e7 Input Format The first and only argument is an integer array, A. Output Format Return an integer, representing the maximum possible profit. Example Input Input 1: A = [1, 2, 1, 2] Input 2: A = [7, 2, 4, 8, 7] Example Output Output 1: 2 Output 2: 6 Example Explanation Explanation 1: Day 0 : Buy Day 1 : Sell Day 2 : Buy Day 3 : Sell Explanation 2: Day 1 : Buy Day 3 : Sell": "INF = float('inf')\n\nclass Solution:\n\t# @param A : tuple of integers\n\t# @return an integer\n\tdef maxProfit(self, A):\n\t    ''' For one transaction, we can do it linearly:\n\t           price that day - minimum seen so far.\n\t           \n\t        For two transactions, we evaluates this at day i + best for remaining days.\n\t    '''\n\t    \n\t    # Best solutions based on increasing starting days\n\t    # We are doing it backward\n\t    bystart = []\n\t    high = -INF # maximum so far\n\t    best = 0\n\t    for x in reversed(A):\n\t        best = max(best, high-x)\n\t        bystart.append(best)\n\t        high = max(high, x)\n\t        \n\t    low = INF # minimum so far\n\t    best = 0\n\t    total = 0\n\t    for x, best2 in zip(A, reversed(bystart)):\n\t        best = max(best, x-low)\n\t        total = max(total, best+best2)\n\t        low = min(low, x)\n\t    \n\t    return total\n\t    \n\t    \n\t    \n\t       \n\n\n", "Say you have an array, A, for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Problem Constraints 0 <= len(A) <= 1e5 1 <= A[i] <= 1e7 Input Format The first and only argument is an array of integers, A. Output Format Return an integer, representing the maximum possible profit. Example Input Input 1: A = [1, 2, 3] Input 2: A = [5, 2, 10] Example Output Output 1: 2 Output 2: 8 Example Explanation Explanation 1: => Buy a stock on day 0. => Sell the stock on day 1. (Profit +1) => Buy a stock on day 1. => Sell the stock on day 2. (Profit +1) Overall Profit = 2 Explanation 2: => Buy a stock on day 1. => Sell the stock on on day 2. (Profit +8) Overall profit = 8": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def maxProfit(self, A):\n        p=0\n        for i in range(len(A)-1):\n            if A[i]<A[i+1]:\n                p+= (A[i+1]-A[i])\n        return p\n\n\n", "A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given an encoded message A containing digits, determine the total number of ways to decode it modulo 109 + 7. Problem Constraints 1 <= |A| <= 105 Input Format The first and the only argument is a string A. Output Format Return a single integer denoting the total number of ways to decode it modulo 109 + 7. Example Input Input 1: A = \"8\" Input 2: A = \"12\" Example Output Output 1: 1 Output 2: 2 Example Explanation Explanation 1: Given encoded message \"8\", it could be decoded as only \"H\" (8). The number of ways decoding \"8\" is 1. Explanation 2: Given encoded message \"12\", it could be decoded as \"AB\" (1, 2) or \"L\" (12). The number of ways decoding \"12\" is 2.": "class Solution:\n    # @param A : string\n    # @return an integer\n    def numDecodings(self, A):\n        A=list(A)\n        n=len(A)\n        x=[0]*(n+1);\n        x[0]=1;\n        x[1]=1\n        if(A[0]=='0'):\n            return 0\n        for i in range(1,n):\n            if(int(A[i-1]+A[i])<=26 and int(A[i-1]+A[i])>0):\n                f=1\n            else:\n                f=0\n            if(A[i]=='0'):\n                x[i+1]=x[i-1]*f\n                if(x[i+1]==0):\n                    x[n]=0\n                    break\n                x[i]=0\n            else:\n                x[i+1]=x[i]+x[i-1]*f\n        return x[n]\n            \n            \n\n\n", "Find the contiguous subarray within an array (containing at least one number) which has the largest product. Return an integer corresponding to the maximum product possible. Example : Input : [2, 3, -2, 4] Return : 6 Possible with [2, 3]": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def maxProduct(self, A):\n        assert len(A) > 0\n        ans = A[0]\n        ma, mi = 1, 1\n        for a in A:\n            ma, mi = max(a, a*ma, a*mi), min(a, a*ma, a*mi)\n            ans = max(ans, ma, mi)\n        return ans\n            \n\n\n", "Given a grid of size m * n, lets assume you are starting at (1,1) and your goal is to reach (m,n). At any instance, if you are on (x,y), you can either go to (x, y + 1) or (x + 1, y). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Example : There is one obstacle in the middle of a 3x3 grid as illustrated below. [ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2. Note: m and n will be at most 100.": "class Solution:\n    # @param A : list of list of integers\n    # @return an integer\n    def uniquePathsWithObstacles(self, A):\n        x=[[0]*len(A[0]) for i in range(len(A))]\n        \n        \n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j]==0:\n                    if j==0 and i==0:\n                        x[i][j]=1\n                    elif j==0:\n                        x[i][j]=x[i-1][j]\n                    elif i==0:\n                        x[i][j]=x[i][j-1]\n                    else:\n                        x[i][j]=x[i-1][j]+x[i][j-1]\n        #print(x)\n        return x[len(A)-1][len(A[0])-1]\n                    \n                    \n\n\n\n", "Given two sequences A, B, count number of unique ways in sequence A, to form a subsequence that is identical to the sequence B. Subsequence : A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u201cACE\u201d is a subsequence of \u201cABCDE\u201d while \u201cAEC\u201d is not). Input Format: The first argument of input contains a string, A. The second argument of input contains a string, B. Output Format: Return an integer representing the answer as described in the problem statement. Constraints: 1 <= length(A), length(B) <= 700 Example : Input 1: A = \"abc\" B = \"abc\" Output 1: 1 Explanation 1: Both the strings are equal. Input 2: A = \"rabbbit\" B = \"rabbit\" Output 2: 3 Explanation 2: These are the possible removals of characters: => A = \"ra_bbit\" => A = \"rab_bit\" => A = \"rabb_it\" Note: \"_\" marks the removed character.": "def findSubsequenceCount(S, T): \n  \n    m = len(T) \n    n = len(S) \n  \n    # T can't appear as a subsequence in S \n    if m > n: \n        return 0\n  \n    # mat[i][j] stores the count of  \n    # occurrences of T(1..i) in S(1..j). \n    mat = [[0 for _ in range(n + 1)] \n              for __ in range(m + 1)] \n  \n    # Initializing first column with all 0s. x \n    # An empty string can't have another \n    # string as suhsequence \n    for i in range(1, m + 1): \n        mat[i][0] = 0\n  \n    # Initializing first row with all 1s.  \n    # An empty string is subsequence of all. \n    for j in range(n + 1): \n        mat[0][j] = 1\n  \n    # Fill mat[][] in bottom up manner \n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n  \n            # If last characters don't match,  \n            # then value is same as the value  \n            # without last character in S. \n            if T[i - 1] != S[j - 1]: \n                mat[i][j] = mat[i][j - 1] \n                  \n            # Else value is obtained considering two cases. \n            # a) All substrings without last character in S \n            # b) All substrings without last characters in \n            # both. \n            else: \n                mat[i][j] = (mat[i][j - 1] + \n                             mat[i - 1][j - 1]) \n  \n    return mat[m][n] \nclass Solution:\n\t# @param A : string\n\t# @param B : string\n\t# @return an integer\n\tdef numDistinct(self, A, B):\n\t    return findSubsequenceCount(A,B)\n", "Given a 2D binary matrix filled with 0\u2019s and 1\u2019s, find the largest rectangle containing all ones and return its area. Bonus if you can solve it in O(n^2) or less. Example : A : [ 1 1 1 0 1 1 1 0 0 ] Output : 4 As the max area rectangle is created by the 2x2 rectangle created by (0,1), (0,2), (1,1) and (1,2)": "class Solution:\n    # @param A : list of list of integers\n    # @return an integer\n    def maximalRectangle(self, A):\n        n=len(A)\n        m=len(A[0])\n        for i in range(m):\n            s=0\n            for j in range(n):\n                if A[j][i]==1:\n                    s+=1\n                    A[j][i]=s\n                else:\n                    s=0\n        resultArea=0\n        for i in range(n):\n            firstMinLeft=[]\n            firstMinRight=[]\n            st=[]\n            for j in range(m):\n                while st and st[-1][0]>=A[i][j]:\n                    st.pop()\n                if st:\n                    firstMinLeft.append(st[-1][1])\n                else:\n                    firstMinLeft.append(-1)\n                st.append((A[i][j],j))\n            st=[]\n            for j in range(m-1,-1,-1):\n                while st and st[-1][0]>=A[i][j]:\n                    st.pop()\n                if st:\n                    firstMinRight.append(st[-1][1])\n                else:\n                    firstMinRight.append(m)\n                st.append((A[i][j],j))\n            firstMinRight=firstMinRight[::-1]\n            for j in range(m):\n                area=(firstMinRight[j]-firstMinLeft[j]-1)*A[i][j]\n                resultArea=max(area,resultArea)\n        return resultArea\n            \n            \n            \n            \n                \n\n\n\n", "Find the longest increasing subsequence of a given array of integers, A. In other words, find a subsequence of array in which the subsequence's elements are in strictly increasing order, and in which the subsequence is as long as possible. In this case, return the length of the longest increasing subsequence. Problem Constraints 1 <= length(A) <= 2500 0 <= A[i] <= 2500 Input Format The first and the only argument is an integer array A. Output Format Return an integer representing the length of the longest increasing subsequence. Example Input Input 1: A = [1, 2, 1, 5] Input 2: A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] Example Output Output 1: 3 Output 2: 6 Example Explanation Explanation 1: The longest increasing subsequence: [1, 2, 5] Explanation 2: The possible longest increasing subsequences: [0, 2, 6, 9, 13, 15] or [0, 4, 6, 9, 11, 15] or [0, 4, 6, 9, 13, 15]": "from bisect import insort,bisect_left,bisect_right\nclass Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def lis(self, A):\n        d = [A[0]]\n        n = len(A)\n        for i in range(1,n):\n            if d[-1] < A[i]:\n                d.append(A[i])\n            else:\n                idx = bisect_left(d,A[i])\n                d[idx] = A[i]\n            \n        return len(d)\n\n\n", "N children are standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: * Each child must have at least one candy. * Children with a higher rating get more candies than their neighbors. What is the minimum number of candies you must give? Problem Constraints 1 <= N <= 105 -109 <= A[i] <= 109 Input Format The first and only argument is an integer array A representing the rating of children. Output Format Return an integer representing the minimum candies to be given. Example Input Input 1: A = [1, 2] Input 2: A = [1, 5, 2, 1] Example Output Output 1: 3 Output 2: 7 Example Explanation Explanation 1: The candidate with 1 rating gets 1 candy and candidate with rating 2 cannot get 1 candy as 1 is its neighbor. So rating 2 candidate gets 2 candies. In total, 2 + 1 = 3 candies need to be given out. Explanation 2: Candies given = [1, 3, 2, 1]": "class Solution:\n    # @param A : list of integers\n    # @return an integer\n    def candy(self, A):\n        n = len(A)\n        arr = [1 for i in range(n)]\n        for i in range(1, n):\n            if A[i] > A[i-1]:\n                arr[i] = arr[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if A[i] > A[i+1] and arr[i] <= arr[i+1]:\n                arr[i] = arr[i+1] + 1\n         \n        return sum(arr)\n            \n\n\n\n", "Given an array of size N, find the majority element. The majority element is the element that appears more than floor(N/2) times. You may assume that the array is non-empty and the majority element always exist in the array. Problem Constraints 1 <= |A| <= 106 1 <= Ai <= 109 Input Format The first argument is an integer array A. Output Format Return the majority element. Example Input A = [2, 1, 2] Example Output 2 Example Explanation 2 occurs 2 times which is greater than 3/2.": "class Solution:\n    # @param A : tuple of integers\n    # @return an integer\n    def majorityElement(self, A):\n        my_freq_map = {k:0 for k in set(A)}\n        N = len(A)\n        for el in A:\n            my_freq_map[el] += 1\n            if my_freq_map[el]>(N//2):\n                return el\n\n\n", "Given two integer arrays A and B of size N. There are N gas stations along a circular route, where the amount of gas at station i is A[i]. You have a car with an unlimited gas tank and it costs B[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the minimum starting gas station's index if you can travel around the circuit once, otherwise return -1. You can only travel in one direction. i to i+1, i+2, ... n-1, 0, 1, 2.. Completing the circuit means starting at i and ending up at i again. Problem Constraints 1 <= |A| <= 5 * 105 |A| == |B| 0 <= Ai <= 5 * 103 0 <= Bi <= 5 * 103 Input Format The first argument given is the integer array A. The second argument given is the integer array B. Output Format Return the minimum starting gas station's index if you can travel around the circuit once, otherwise return -1. Example Input A = [1, 2] B = [2, 1] Example Output 1 Example Explanation If you start from index 0, you can fill in A[0] = 1 amount of gas. Now your tank has 1 unit of gas. But you need B[0] = 2 gas to travel to station 1. If you start from index 1, you can fill in A[1] = 2 amount of gas. Now your tank has 2 units of gas. You need B[1] = 1 gas to get to station 0. So, you travel to station 0 and still have 1 unit of gas left over. You fill in A[0] = 1 unit of additional gas, making your current gas = 2. It costs you B[0] = 2 to get to station 1, which you do and complete the circuit.": "class Solution:\n    # @param gas : tuple of integers\n    # @param cost : tuple of integers\n    # @return an integer\n    def canCompleteCircuit(self, gas, cost):\n        cumm_gas, cum_cost = 0,0\n        tank,start = 0,0\n        for i in range(len(gas)):\n            cumm_gas += gas[i]\n            cum_cost += cost[i]\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                tank = 0\n                start = i+1\n        if cumm_gas < cum_cost: return -1\n        return start", "Introduction to Matrix or Grid - Data Structure and Algorithms Tutorial - GeeksforGeeks": ["arr = [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ], [ 9, 10, 11, 12] ] \n  \nfor i in range(0,3): \n  for j in range(0,4): \n      \n    print(arr[i][j],end = ' ') \n  print('') \n  \n# This code is contributed by akashish__ \n", "# Python code for above approach \ndef searchInMatrix(arr, x): \n    # m=4,n=5 \n    for i in range(0, 4): \n        for j in range(0, 5): \n            if(arr[i][j] == x): \n                return 1\n    return\n  \nx = 8\narr = [[0, 6, 8, 9, 11], \n       [20, 22, 28, 29, 31], \n       [36, 38, 50, 61, 63], \n       [64, 66, 100, 122, 128]] \nif(searchInMatrix(arr, x)): \n    print('YES') \nelse: \n    print('NO') \n  \n    # This code is contributed by ishankhandelwals.\n", "# Python3 Program to print the Diagonals of a Matrix \nMAX = 100\n  \n# Function to print the Principal Diagonal \ndef printPrincipalDiagonal(mat, n): \n    print('Principal Diagonal: ',end='') \n  \n    for i in range(0,n): \n        for j in range(0,n): \n  \n            # Condition for principal diagonal \n            if (i == j): \n                print(mat[i][j] , ', ', end='') \n    print('') \n  \n# Function to print the Secondary Diagonal \ndef printSecondaryDiagonal(mat, n): \n    print('Secondary Diagonal: ',end = '') \n  \n    for i in range(0,n): \n        for j in range(0,n): \n  \n            # Condition for secondary diagonal \n            if ((i + j) == (n - 1)): \n                print(mat[i][j] , ', ', end = '') \n    print('') \n  \n# Driver code \nn = 4\na = [ [ 1, 2, 3, 4 ], \n                    [ 5, 6, 7, 8 ], \n                    [ 1, 2, 3, 4 ], \n                    [ 5, 6, 7, 8 ] ] \n  \nprintPrincipalDiagonal(a, n) \nprintSecondaryDiagonal(a, n) \n  \n# This code is contributed by akashish__ \n", "# Python Implementation to sort the given matrix \ndef sortMat(mat, n):  \n    \n    # temporary matrix of size n^2  \n    temp = [0]*n*n  \n    k = 0\n    \n    # copy the elements of matrix one by one  \n    # leto temp[]  \n    for i in range(0, n):  \n        for j in range(0, n):  \n            temp[k] = mat[i][j]  \n            k += 1\n    \n    # sort temp[]  \n    temp.sort(reverse = True)  \n    \n    # copy the elements of temp[] one by one  \n    # in mat[][]  \n    k = 0\n    for i in range(0, n):  \n        for j in range(0, n):  \n            mat[i][j] = temp[k]  \n            k += 1\n    \n# function to print the given matrix  \ndef printMat(mat, n):  \n    for i in range(0, n):  \n        for j in range(0, n):  \n            print(mat[i][j], end = ' ')  \n        print('')  \n    \n# Driver program to test above  \nmat = [[5, 4, 7],  \n       [1, 3, 8],  \n       [2, 9, 6]]  \nn = 3\n    \nprint('Original Matrix:')  \nprintMat(mat, n)  \nsortMat(mat, n)  \nprint('\\nMatrix After Sorting:')  \nprintMat(mat, n) \n  \n# This code is contributed by ishankhandelwals.\n", "# Python program for left rotation of matrix by 180 \nR = 4\nC = 4\n  \n# Function to rotate the matrix by 180 degree \ndef reverseColumns(arr):  \n  for i in range(C):  \n    for j in range(0, int(C / 2)):  \n      x = arr[j][i]  \n      arr[j][i] = arr[C - 1 - j][i]  \n      arr[C - 1 - j][i] = x  \n  \n# Function for transpose of matrix  \ndef transpose(arr):  \n  for i in range(R):  \n    for j in range(i, C):  \n      x = arr[j][i]  \n      arr[j][i] = arr[i][j]  \n      arr[i][j] = x  \n  \n# Function for display the matrix  \ndef printMatrix(arr):  \n  for i in range(R):  \n    for j in range(C):  \n      print(arr[i][j], end = ' ')  \n    print()  \n  \n# Function to anticlockwise rotate matrix  \n# by 180 degree  \ndef rotate180(arr):  \n  transpose(arr)  \n  reverseColumns(arr)  \n  transpose(arr)  \n  reverseColumns(arr)  \n  \n# Driven code  \narr = [[1, 2, 3, 4 ],  \n              [ 5, 6, 7, 8 ],  \n              [ 9, 10, 11, 12 ],  \n              [ 13, 14, 15, 16 ]]  \nrotate180(arr)  \nprintMatrix(arr) \n  \n# This code is contributed by akashish__\n", "# Python program to find unique \n# element in matrix \n  \n# Function that calculate unique element \ndef unique(mat, n, m): \n    maximum = 0\n    flag = 0\n    for i in range(n): \n        for j in range(m): \n            # Find maximum element in \n            # a matrix \n            if maximum < mat[i][j]: \n                maximum = mat[i][j] \n  \n    # Take 1-D array of (maximum + 1) \n    # size \n    b = [0] * (maximum + 1) \n    for i in range(n): \n        for j in range(m): \n            y = mat[i][j] \n            b[y] += 1\n  \n    # print unique element \n    for i in range(1, maximum+1): \n        if b[i] == 1: \n            print(i, end=' ') \n    flag = 1\n  \n    if flag == 0: \n        print('No unique element in the matrix') \n  \nR = 4\nC = 4\nmat = [[1, 2, 3, 20], \n       [5, 6, 20, 25], \n       [1, 3, 5, 6], \n       [6, 7, 8, 15]] \n  \n# function that calculate unique element \nunique(mat, R, C) \n  \n# This code is contributed by lokesh.\n"], "Given a string A and a dictionary of words B, determine if A can be segmented into a space-separated sequence of one or more dictionary words. Problem Constraints 1 <= len(A) <= 6500 1 <= len(B) <= 10000 1 <= len(B[i]) <= 20 Input Format The first argument is a string, A. The second argument is an array of strings, B. Output Format Return 0 / 1 ( 0 for false, 1 for true ) for this problem. Example Input Input 1: A = \"myinterviewtrainer\", B = [\"trainer\", \"my\", \"interview\"] Input 2:A = \"a\" B = [\"aaa\"] Example Output Output 1:1 Output 2:0 Example Explanation Explanation 1:Return 1 ( corresponding to true ) because \"myinterviewtrainer\" can be segmented as \"my interview trainer\". Explanation 2: Return 0 ( corresponding to false ) because \"a\" cannot be segmented as \"aaa\".": "class Solution:\n    # @param s, a string\n    # @param dict, a set of string\n    # @return a boolean\n    def wordBreak(self, s, word_dict):\n        stack = [1]\n        for i in range (0, len(s)):\n            stack.append(0)\n            for j in range(i,-1,-1):\n                if stack[j] and s[j:i+1] in word_dict:\n                    stack[i+1] = 1\n                    break\n        return stack[len(s)]", "Introduction to Map \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python program to count frequencies of array items \nfrom collections import defaultdict \n  \ndef countFreq(arr): \n    freq = defaultdict(int) \n  \n    # Traverse through array elements and count frequencies \n    for i in arr: \n        freq[i] += 1\n  \n    # Traverse through dictionary and print frequencies \n    for key, value in freq.items(): \n        print(key, value) \n  \n# Driver code \nif __name__ == '__main__': \n    arr = [1, 2, 3, 3, 4, 5, 5, 5] \n    countFreq(arr) \n"], "Introduction to Set \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# set of letters \nGEEK = {10, 5, 12, 4} \n  \n# adding 's' \nGEEK.add(15) \nprint('Letters are:', GEEK) \n  \n# adding 's' again \nGEEK.add(10) \nprint('Letters are:', GEEK) \n  \n# check if set contain an element \nprint(5 in GEEK) \n  \n# removing an element from set \nGEEK.remove(5) \nprint(GEEK) \n  \n# print max element of set \nprint(max(GEEK)) \n  \n# print min element of set \nprint(min(GEEK)) \n  \n# printing size of the set \nprint(len(GEEK)) \n", "# Python program to demonstrate various functions of set \n  \n# Creating an empty set \nset = set() \n  \n# Use add() method to add elements into the set \nset.add(1) \nset.add(2) \nset.add(3) \nset.add(4) \nset.add(5) \n  \n# Displaying the set \nprint('Set:', set) \n  \n# Creating an iterator \nvalue = iter(set) \n  \n# Displaying the values after iterating through the iterator \nprint('The iterator values are:') \nwhile True: \n    try: \n        print(next(value)) \n    except StopIteration: \n        break\n"], "Introduction to Heap - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python code to depict \n# the implementation of a max heap. \n  \nclass MaxHeap: \n    # A pointer pointing to the elements \n    # in the array in the heap. \n    arr = [] \n  \n    # Maximum possible size of \n    # the Max Heap. \n    maxSize = 0\n  \n    # Number of elements in the \n    # Max heap currently. \n    heapSize = 0\n  \n    # Constructor function. \n    def __init__(self, maxSize): \n        self.maxSize = maxSize \n        self.arr = [None]*maxSize \n        self.heapSize = 0\n  \n    # Heapifies a sub-tree taking the \n    # given index as the root. \n    def MaxHeapify(self, i): \n        l = self.lChild(i) \n        r = self.rChild(i) \n        largest = i \n        if l < self.heapSize and self.arr[l] > self.arr[i]: \n            largest = l \n        if r < self.heapSize and self.arr[r] > self.arr[largest]: \n            largest = r \n        if largest != i: \n            temp = self.arr[i] \n            self.arr[i] = self.arr[largest] \n            self.arr[largest] = temp \n            self.MaxHeapify(largest) \n  \n    # Returns the index of the parent \n    # of the element at ith index. \n    def parent(self, i): \n        return (i - 1) // 2\n  \n    # Returns the index of the left child. \n    def lChild(self, i): \n        return (2 * i + 1) \n  \n    # Returns the index of the \n    # right child. \n    def rChild(self, i): \n        return (2 * i + 2) \n  \n    # Removes the root which in this \n    # case contains the maximum element. \n    def removeMax(self): \n        # Checking whether the heap array \n        # is empty or not. \n        if self.heapSize <= 0: \n            return None\n        if self.heapSize == 1: \n            self.heapSize -= 1\n            return self.arr[0] \n  \n        # Storing the maximum element \n        # to remove it. \n        root = self.arr[0] \n        self.arr[0] = self.arr[self.heapSize - 1] \n        self.heapSize -= 1\n  \n        # To restore the property \n        # of the Max heap. \n        self.MaxHeapify(0) \n  \n        return root \n  \n    # Increases value of key at \n    # index 'i' to new_val. \n    def increaseKey(self, i, newVal): \n        self.arr[i] = newVal \n        while i != 0 and self.arr[self.parent(i)] < self.arr[i]: \n            temp = self.arr[i] \n            self.arr[i] = self.arr[self.parent(i)] \n            self.arr[self.parent(i)] = temp \n            i = self.parent(i) \n  \n    # Returns the maximum key \n    # (key at root) from max heap. \n    def getMax(self): \n        return self.arr[0] \n  \n    def curSize(self): \n        return self.heapSize \n  \n    # Deletes a key at given index i. \n    def deleteKey(self, i): \n        # It increases the value of the key \n        # to infinity and then removes \n        # the maximum value. \n        self.increaseKey(i, float('inf')) \n        self.removeMax() \n  \n    # Inserts a new key 'x' in the Max Heap. \n    def insertKey(self, x): \n        # To check whether the key \n        # can be inserted or not. \n        if self.heapSize == self.maxSize: \n            print('\\nOverflow: Could not insertKey\\n') \n            return\n  \n        # The new key is initially \n        # inserted at the end. \n        self.heapSize += 1\n        i = self.heapSize - 1\n        self.arr[i] = x \n  \n        # The max heap property is checked \n        # and if violation occurs, \n        # it is restored. \n        while i != 0 and self.arr[self.parent(i)] < self.arr[i]: \n            temp = self.arr[i] \n            self.arr[i] = self.arr[self.parent(i)] \n            self.arr[self.parent(i)] = temp \n            i = self.parent(i) \n  \n  \n# Driver program to test above functions. \nif __name__ == '__main__': \n    # Assuming the maximum size of the heap to be 15. \n    h = MaxHeap(15) \n  \n    # Asking the user to input the keys: \n    k, i, n = 6, 0, 6\n    print('Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n') \n    h.insertKey(3) \n    h.insertKey(10) \n    h.insertKey(12) \n    h.insertKey(8) \n    h.insertKey(2) \n    h.insertKey(14) \n  \n    # Printing the current size \n    # of the heap. \n    print('The current size of the heap is '\n          + str(h.curSize()) + '\\n') \n  \n    # Printing the root element which is \n    # actually the maximum element. \n    print('The current maximum element is ' + str(h.getMax()) \n          + '\\n') \n  \n    # Deleting key at index 2. \n    h.deleteKey(2) \n  \n    # Printing the size of the heap \n    # after deletion. \n    print('The current size of the heap is '\n          + str(h.curSize()) + '\\n') \n  \n    # Inserting 2 new keys into the heap. \n    h.insertKey(15) \n    h.insertKey(5) \n    print('The current size of the heap is '\n          + str(h.curSize()) + '\\n') \n    print('The current maximum element is ' + str(h.getMax()) \n          + '\\n')\n"], "Introduction to Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# python program to demonstrate some of the above\n# terminologies\n \n# Function to add an edge between vertices x and y\n \n# Function to print the parent of each node\n \n \ndef printParents(node, adj, parent):\n \n    # current node is Root, thus, has no parent\n    if (parent == 0):\n        print(node, '->Root')\n    else:\n        print(node, '->', parent)\n \n    # Using DFS\n    for cur in adj[node]:\n        if (cur != parent):\n            printParents(cur, adj, node)\n \n# Function to print the children of each node\n \n \ndef printChildren(Root, adj):\n \n    # Queue for the BFS\n    q = []\n \n    # pushing the root\n    q.append(Root)\n \n    # visit array to keep track of nodes that have been\n    # visited\n    vis = [0]*len(adj)\n \n    # BFS\n    while (len(q) > 0):\n        node = q[0]\n        q.pop(0)\n        vis[node] = 1\n        print(node, '-> ', end=' ')\n \n        for cur in adj[node]:\n            if (vis[cur] == 0):\n                print(cur, ' ', end=' ')\n                q.append(cur)\n        print('\\n')\n \n# Function to print the leaf nodes\n \n \ndef printLeafNodes(Root, adj):\n \n    # Leaf nodes have only one edge and are not the root\n    for i in range(0, len(adj)):\n        if (len(adj[i]) == 1 and i != Root):\n            print(i, end=' ')\n    print('\\n')\n \n# Function to print the degrees of each node\n \n \ndef printDegrees(Root, adj):\n \n    for i in range(1, len(adj)):\n        print(i, ': ', end=' ')\n \n        # Root has no parent, thus, its degree is equal to\n        # the edges it is connected to\n        if (i == Root):\n            print(len(adj[i]))\n        else:\n            print(len(adj[i])-1)\n \n# Driver code\n \n \n# Number of nodes\nN = 7\nRoot = 1\n \n# Adjacency list to store the tree\nadj = []\nfor i in range(0, N+1):\n    adj.append([])\n \n# Creating the tree\nadj[1].append(2)\nadj[2].append(1)\n \nadj[1].append(3)\nadj[3].append(1)\n \nadj[1].append(4)\nadj[4].append(1)\n \nadj[2].append(5)\nadj[5].append(2)\n \nadj[2].append(6)\nadj[6].append(2)\n \nadj[4].append(7)\nadj[7].append(4)\n \n# Printing the parents of each node\nprint('The parents of each node are:')\nprintParents(Root, adj, 0)\n \n# Printing the children of each node\nprint('The children of each node are:')\nprintChildren(Root, adj)\n \n# Printing the leaf nodes in the tree\nprint('The leaf nodes of the tree are:')\nprintLeafNodes(Root, adj)\n \n# Printing the degrees of each node\nprint('The degrees of each node are:')\nprintDegrees(Root, adj)\n \n# This code is contributed by rj13to.\n"], "Introduction of B-Tree - GeeksforGeeks": ["class Node:\n    def __init__(self):\n        self.n = 0\n        self.key = [0] * MAX_KEYS\n        self.child = [None] * MAX_CHILDREN\n        self.leaf = True\n \ndef BtreeSearch(x, k):\n    i = 0\n    while i < x.n and k >= x.key[i]:\n        i += 1\n    if i < x.n and k == x.key[i]:\n        return x\n    if x.leaf:\n        return None\n    return BtreeSearch(x.child[i], k)\n", "# Create a node\nclass BTreeNode:\n  def __init__(self, leaf=False):\n    self.leaf = leaf\n    self.keys = []\n    self.child = []\n \n \n# Tree\nclass BTree:\n  def __init__(self, t):\n    self.root = BTreeNode(True)\n    self.t = t\n \n    # Insert node\n  def insert(self, k):\n    root = self.root\n    if len(root.keys) == (2 * self.t) - 1:\n      temp = BTreeNode()\n      self.root = temp\n      temp.child.insert(0, root)\n      self.split_child(temp, 0)\n      self.insert_non_full(temp, k)\n    else:\n      self.insert_non_full(root, k)\n \n    # Insert nonfull\n  def insert_non_full(self, x, k):\n    i = len(x.keys) - 1\n    if x.leaf:\n      x.keys.append((None, None))\n      while i >= 0 and k[0] < x.keys[i][0]:\n        x.keys[i + 1] = x.keys[i]\n        i -= 1\n      x.keys[i + 1] = k\n    else:\n      while i >= 0 and k[0] < x.keys[i][0]:\n        i -= 1\n      i += 1\n      if len(x.child[i].keys) == (2 * self.t) - 1:\n        self.split_child(x, i)\n        if k[0] > x.keys[i][0]:\n          i += 1\n      self.insert_non_full(x.child[i], k)\n \n    # Split the child\n  def split_child(self, x, i):\n    t = self.t\n    y = x.child[i]\n    z = BTreeNode(y.leaf)\n    x.child.insert(i + 1, z)\n    x.keys.insert(i, y.keys[t - 1])\n    z.keys = y.keys[t: (2 * t) - 1]\n    y.keys = y.keys[0: t - 1]\n    if not y.leaf:\n      z.child = y.child[t: 2 * t]\n      y.child = y.child[0: t - 1]\n \n  # Print the tree\n  def print_tree(self, x, l=0):\n    print('Level ', l, ' ', len(x.keys), end=':')\n    for i in x.keys:\n      print(i, end=' ')\n    print()\n    l += 1\n    if len(x.child) > 0:\n      for i in x.child:\n        self.print_tree(i, l)\n \n  # Search key in the tree\n  def search_key(self, k, x=None):\n    if x is not None:\n      i = 0\n      while i < len(x.keys) and k > x.keys[i][0]:\n        i += 1\n      if i < len(x.keys) and k == x.keys[i][0]:\n        return (x, i)\n      elif x.leaf:\n        return None\n      else:\n        return self.search_key(k, x.child[i])\n       \n    else:\n      return self.search_key(k, self.root)\n \n \ndef main():\n  B = BTree(3)\n \n  for i in range(10):\n    B.insert((i, 2 * i))\n \n  B.print_tree(B.root)\n \n  if B.search_key(8) is not None:\n    print('\\nFound')\n  else:\n    print('\\nNot Found')\n \n \nif __name__ == '__main__':\n  main()\n"], "Introduction to Binary Search Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python program to insert a node \n# in a BST \n  \n# Given Node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to do inorder traversal of BST \ndef inorder(root): \n    if root is not None: \n        inorder(root.left) \n        print(root.key, end=' ') \n        inorder(root.right) \n  \n# Driver Code \nif __name__ == '__main__': \n    ''' \n    Let us create following BST \n          50 \n       /     \\ \n      30      70 \n     /  \\    /  \\ \n    20  40  60   80 \n    '''\n    root = None\n  \n    # Inserting value 50 \n    root = insert(root, 50) \n  \n    # Inserting value 30 \n    insert(root, 30) \n  \n    # Inserting value 20 \n    insert(root, 20) \n  \n    # Inserting value 40 \n    insert(root, 40) \n  \n    # Inserting value 70 \n    insert(root, 70) \n  \n    # Inserting value 60 \n    insert(root, 60) \n  \n    # Inserting value 80 \n    insert(root, 80) \n  \n    # Print the BST \n    inorder(root) \n      \n#This code is contributed by japmeet01\n", "# Python program to implement \n# inorder traversal of BST \n  \n# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to create a new BST node \ndef newNode(item): \n    temp = Node(item) \n    temp.key = item \n    temp.left = temp.right = None\n    return temp \n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return newNode(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to do inorder traversal of BST \ndef inorder(root): \n    if root: \n        inorder(root.left) \n        print(root.key, end=' ') \n        inorder(root.right) \n  \n# Driver Code \nif __name__ == '__main__': \n      \n    # Let us create following BST  \n    #          50  \n    #       /     \\  \n    #     30      70  \n    #    /  \\    /  \\  \n    #  20   40  60   80  \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    inorder(root) \n#This code is contributed by japmeet01\n", "# Python program to implement preorder traversal \nclass Node: \n    # Constructor to create a new node \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \n  \n  \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to do preorder traversal of BST \n  \n  \ndef preOrder(root): \n    if root: \n        print(root.key, end=' ') \n        preOrder(root.left) \n        preOrder(root.right) \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    ''' \n        Let us create following BST \n              50 \n           /     \\ \n          30      70 \n         /  \\    /  \\ \n       20   40  60   80 \n   '''\n    root = None\n    keys = [50, 30, 20, 40, 70, 60, 80] \n  \n    # Creating the BST \n    for key in keys: \n        root = insert(root, key) \n  \n    # Function Call \n    preOrder(root) \n#This code is contributed by japmeet01\n", "# Python program to print total count of nodes in BST \n  \n# Define the Node class \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to do postorder traversal of BST \ndef postOrder(root): \n    if root: \n        postOrder(root.left) \n        postOrder(root.right) \n        print(root.key, end=' ') \n  \n# Driver code \nif __name__ == '__main__': \n    # Let us create following BST  \n    #           50  \n    #        /     \\  \n    #       30      70  \n    #      /  \\    /  \\  \n    #    20   40  60   80  \n  \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function call \n    postOrder(root) \n  \n    #This code is contributed by japmeet01\n", "# Python program to implement \n# level order traversal \nimport queue \n  \n# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Returns height of the BST \ndef height(node): \n    if node is None: \n        return 0\n    else: \n        # Compute the depth of each subtree \n        lDepth = height(node.left) \n        rDepth = height(node.right) \n  \n        # Use the larger one \n        if lDepth > rDepth: \n            return (lDepth + 1) \n        else: \n            return (rDepth + 1) \n  \n# Print nodes at a given level \ndef printGivenLevel(root, level): \n    if root is None: \n        return\n    if level == 1: \n        print(root.key, end=' ') \n    elif level > 1: \n        # Recursive call \n        printGivenLevel(root.left, level - 1) \n        printGivenLevel(root.right, level - 1) \n  \n# Function to line by line print \n# level order traversal of a tree \ndef printLevelOrder(root): \n    h = height(root) \n    for i in range(1, h+1): \n        printGivenLevel(root, i) \n        print() \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #          50 \n    #       /     \\ \n    #      30      70 \n    #     /  \\    /  \\ \n    #   20   40  60   80 \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    printLevelOrder(root) \n      \n    #This code is contributed by japmeet01 \n", "# Python program to print nodes at a given level \n  \n# Given Node node \n  \n  \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \n  \n  \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Print nodes at a given level \n  \n  \ndef printGivenLevel(root, level): \n    if root is None: \n        return\n    if level == 1: \n        print(root.key, end=' ') \n    elif level > 1: \n        # Recursive Call \n        printGivenLevel(root.left, level - 1) \n        printGivenLevel(root.right, level - 1) \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #           50 \n    #        /     \\ \n    #       30      70 \n    #      /  \\    /  \\ \n    #     20   40  60   80 \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    printGivenLevel(root, 2) \n  \n    # This code is contributed by japmeet01 \n", "# Python program to print all \n# leaf nodes of a BST \n  \n# Given Node node \nclass Node: \n    def __init__(self, item): \n        self.key = item \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to print leaf nodes \n# from left to right \ndef printLeafNodes(root): \n    # If node is null, return \n    if not root: \n        return\n  \n    # If node is leaf node, \n    # print its data \n    if not root.left and not root.right: \n        print(root.key, end=' ') \n  \n    # If left child exists, \n    # check for leaf recursively \n    if root.left: \n        printLeafNodes(root.left) \n  \n    # If right child exists, \n    # check for leaf recursively \n    if root.right: \n        printLeafNodes(root.right) \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #          50 \n    #        /    \\ \n    #      30      70 \n    #     /  \\    /  \\ \n    #   20   40  60   80 \n  \n    # Creating the BST \n    root = None\n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    printLeafNodes(root) \n  \n    #This code is contributed by japmeet01\n", "# Python program to print all \n# non leaf nodes of a BST \n  \n# Given Node node \n  \n  \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \n  \n  \ndef insert(root, key): \n    # If the tree is empty, return a new node \n    if root is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < root.key: \n        root.left = insert(root.left, key) \n    elif key > root.key: \n        root.right = insert(root.right, key) \n  \n    # Return the node pointer \n    return root \n  \n# Function to print all non-leaf \n# nodes in a tree \n  \n  \ndef printNonLeafNode(root): \n    # Base Cases \n    if root is None or (root.left is None and root.right is None): \n        return\n  \n    # If current node is non-leaf, \n    if root.left is not None or root.right is not None: \n        print(root.key, end=' ') \n  \n    # If root is Not NULL and its one \n    # of its child is also not NULL \n    printNonLeafNode(root.left) \n    printNonLeafNode(root.right) \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #           50 \n    #        /     \\ \n    #      30       70 \n    #     /  \\     /  \\ \n    #   20   40   60   80 \n  \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    printNonLeafNode(root) \n  \n    # This code is contributed by japmeet01 \n", "# Python program to print right view of a BST \nimport sys \n  \n# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    else: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to print the right view \n# of a binary tree. \ndef rightViewUtil(root, level, max_level): \n    # Base Case \n    if root is None: \n        return\n  \n    # If this is the last Node of its level \n    if (max_level[0] < level): \n        print('\\t', root.key, end='') \n        max_level[0] = level \n  \n    # Recur for right subtree first, \n    # then left subtree \n    rightViewUtil(root.right, level + 1, max_level) \n    rightViewUtil(root.left, level + 1, max_level) \n  \n# Wrapper over rightViewUtil() \ndef rightView(root): \n    max_level = [0] \n    rightViewUtil(root, 1, max_level) \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #        50 \n    #     /     \\ \n    #    30      70 \n    #   /  \\    /  \\ \n    #  20  40  60  80 \n  \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    rightView(root) \n      \n    #This code is contributed by japmeet01 \n", "# Python program to print \n# left view of a BST \n  \n# Given Node node \n  \n  \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \n  \n  \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to print left view of \n# binary tree \n  \n  \ndef leftViewUtil(root, level, max_level): \n    # Base Case \n    if root is None: \n        return\n  \n    # If this is the first node \n    # of its level \n    if max_level[0] < level: \n        print(root.key, end=' ') \n        max_level[0] = level \n  \n    # Recur for left and right subtrees \n    leftViewUtil(root.left, level + 1, max_level) \n    leftViewUtil(root.right, level + 1, max_level) \n  \n# Wrapper over leftViewUtil() \n  \n  \ndef leftView(root): \n    max_level = [0] \n    leftViewUtil(root, 1, max_level) \n  \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #          50 \n    #        /    \\ \n    #      30      70 \n    #     /  \\    /  \\ \n    #   20   40  60   80 \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    leftView(root) \n      \n    #This code is contributed by japmeet01 \n", "# Python program to print \n# height of a BST \nimport sys \n  \n# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(root, key): \n    # If the tree is empty, return a new node \n    if root is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < root.key: \n        root.left = insert(root.left, key) \n    elif key > root.key: \n        root.right = insert(root.right, key) \n  \n    # Return the node pointer \n    return root \n  \n# Returns height of the BST \ndef height(node): \n    if node is None: \n        return 0\n    else: \n        # Compute the depth of each subtree \n        lDepth = height(node.left) \n        rDepth = height(node.right) \n  \n        # Use the larger one \n        if lDepth > rDepth: \n            return lDepth + 1\n        else: \n            return rDepth + 1\n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #           50 \n    #        /      \\ \n    #       30       70 \n    #      /  \\     /  \\ \n    #    20   40   60   80 \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    print(' ', height(root)) \n      \n    #This code is contributed by japmeet01 \n", "# Python program to delete a node of BST \n  \n# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(root, key): \n    # If the tree is empty, return a new node \n    if root is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < root.key: \n        root.left = insert(root.left, key) \n    elif key > root.key: \n        root.right = insert(root.right, key) \n  \n    # Return the node pointer \n    return root \n  \n# Function to do inorder traversal of BST \ndef inorder(root): \n    if root: \n        inorder(root.left) \n        print(root.key, end=' ') \n        inorder(root.right) \n  \n# Function that returns the node with minimum \n# key value found in that tree \ndef minValueNode(node): \n    current = node \n  \n    # Loop down to find the leftmost leaf \n    while current and current.left is not None: \n        current = current.left \n  \n    return current \n  \n# Function that deletes the key and \n# returns the new root \ndef deleteNode(root, key): \n    # base Case \n    if root is None: \n        return root \n  \n    # If the key to be deleted is \n    # smaller than the root's key, \n    # then it lies in left subtree \n    if key < root.key: \n        root.left = deleteNode(root.left, key) \n  \n    # If the key to be deleted is \n    # greater than the root's key, \n    # then it lies in right subtree \n    elif key > root.key: \n  \n        root.right = deleteNode(root.right, key) \n  \n    # If key is same as root's key, \n    # then this is the node \n    # to be deleted \n    else: \n  \n        # Node with only one child \n        # or no child \n        if root.left is None: \n            temp = root.right \n            root = None\n            return temp \n        elif root.right is None: \n            temp = root.left \n            root = None\n            return temp \n  \n        # Node with two children: \n        # Get the inorder successor(smallest \n        # in the right subtree) \n        temp = minValueNode(root.right) \n  \n        # Copy the inorder successor's \n        # content to this node \n        root.key = temp.key \n  \n        # Delete the inorder successor \n        root.right = deleteNode(root.right, temp.key) \n  \n    return root \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #          50 \n    #       /     \\ \n    #      30      70 \n    #     /  \\    /  \\ \n    #    20   40 60   80 \n  \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    root = deleteNode(root, 60) \n    inorder(root) \n      \n    #This code is contributed by japmeet01 \n", "# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function that returns the node with minimum \n# key value found in that tree \ndef minValueNode(node): \n    current = node \n  \n    # Loop down to find the leftmost leaf \n    while current and current.left is not None: \n        current = current.left \n  \n    return current \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #           50 \n    #        /     \\ \n    #       30      70 \n    #      /  \\    /  \\ \n    #     20  40  60   80 \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    print(minValueNode(root).key) \n      \n    #This code is contributed by japmeet01 \n", "# Python program to print total \n# count of nodes in BST \n  \n# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to create a new BST node \ndef newNode(item): \n    temp = Node(item) \n    return temp \n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return newNode(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to get the total count of \n# nodes in a binary tree \ndef nodeCount(node): \n    if node is None: \n        return 0\n  \n    else: \n        return nodeCount(node.left) + nodeCount(node.right) + 1\n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #          50 \n    #        /     \\ \n    #       30      70 \n    #      /  \\    /  \\ \n    #    20   40  60   80 \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    # Function Call \n    print(nodeCount(root)) \n    #This code is contributed by japmeet01 \n", "# Python program to delete a BST \n  \n# Given Node node \nclass Node: \n    def __init__(self, key): \n        self.key = key \n        self.left = None\n        self.right = None\n  \n# Function to insert a new node with \n# given key in BST \ndef insert(node, key): \n    # If the tree is empty, return a new node \n    if node is None: \n        return Node(key) \n  \n    # Otherwise, recur down the tree \n    if key < node.key: \n        node.left = insert(node.left, key) \n    elif key > node.key: \n        node.right = insert(node.right, key) \n  \n    # Return the node pointer \n    return node \n  \n# Function to do inorder traversal of BST \ndef inorder(root): \n    if root is not None: \n        inorder(root.left) \n        print(root.key, end=' ') \n        inorder(root.right) \n  \n# Function to delete the BST \ndef emptyBST(root): \n    if root is not None: \n        # Traverse to left subtree \n        emptyBST(root.left) \n  \n        # Traverse to right subtree \n        emptyBST(root.right) \n  \n        print('\\nReleased node:', root.key) \n        # Require for free memory \n        del root \n  \n# Driver Code \nif __name__ == '__main__': \n    # Let us create following BST \n    #           50 \n    #        /     \\ \n    #       30      70 \n    #      /  \\    /  \\ \n    #    20   40  60   80 \n    root = None\n  \n    # Creating the BST \n    root = insert(root, 50) \n    insert(root, 30) \n    insert(root, 20) \n    insert(root, 40) \n    insert(root, 70) \n    insert(root, 60) \n    insert(root, 80) \n  \n    print('BST before deleting:') \n    inorder(root) \n  \n    # Function Call \n    emptyBST(root) \n    #This code is contributed by japmeet01 \n"], "Introduction to Binary Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks": [], "Introduction to Generic Trees (N-ary Trees) - GeeksforGeeks": [], "Introduction to Queue - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Creating an empty queue\n \n# A structure to represent a queue\n \n \nclass Queue:\n        # constructor\n    def __init__(self, cap):\n        self.cap = cap\n        self.front = 0\n        self.size = 0\n        self.rear = cap - 1\n        self.arr = [0] * cap\n \n    # Function to create a queue of given capacity\n    # It initializes size of queue as 0\n    def createQueue(self):\n        return Queue(self.cap)\n \n# This code is contributed by Tapesh (tapeshdua420)\n", "class QNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n \n \nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n \n # This code is contributed by Tapesh (tapeshdua420)\n", "# Function to add an item to the queue.\n# It changes rear and size\n \n \ndef EnQueue(self, item):\n    if self.isFull():\n        print('Full')\n        return\n    self.rear = (self.rear + 1) % (self.capacity)\n    self.Q[self.rear] = item\n    self.size = self.size + 1\n    print('% s enqueued to queue' % str(item))\n# This code is contributed by Susobhan Akhuli\n", "# Function to remove an item from queue.\n# It changes front and size\n \n \ndef DeQueue(self):\n    if self.isEmpty():\n        print('Queue is empty')\n        return\n \n    print('% s dequeued from queue' % str(self.Q[self.front]))\n    self.front = (self.front + 1) % (self.capacity)\n    self.size = self.size - 1\n# This code is contributed by Susobhan Akhuli\n", "# Function to get front of queue\ndef que_front(self):\n        if self.isempty():\n            return 'Queue is empty'\n        return self.Q[self.front]\n \n# This code is contributed By Susobhan Akhuli\n", "def rear(queue):\n    if queue.empty():\n        print('Queue is empty.')\n        return None\n \n    rear_element = None\n    while not queue.empty():\n        rear_element = queue.get()\n \n    return rear_element\n", "# Queue is empty when size is 0\ndef isEmpty(self):\n    return self.size == 0\n# This code is contributed by Susobhan Akhuli\n", "# Queue is full when size becomes\n# equal to the capacity\n \n \ndef isFull(self):\n    return self.size == self.capacity\n \n# This code is contributed by Susobhan Akhuli\n", "# Python3 program for array implementation of queue\n \n# Class Queue to represent a queue\n \n \nclass Queue:\n \n    # __init__ function\n    def __init__(self, capacity):\n        self.front = self.size = 0\n        self.rear = capacity - 1\n        self.Q = [None]*capacity\n        self.capacity = capacity\n \n    # Queue is full when size becomes\n    # equal to the capacity\n    def isFull(self):\n        return self.size == self.capacity\n \n    # Queue is empty when size is 0\n    def isEmpty(self):\n        return self.size == 0\n \n    # Function to add an item to the queue.\n    # It changes rear and size\n    def EnQueue(self, item):\n        if self.isFull():\n            print('Full')\n            return\n        self.rear = (self.rear + 1) % (self.capacity)\n        self.Q[self.rear] = item\n        self.size = self.size + 1\n        print('% s enqueued to queue' % str(item))\n \n    # Function to remove an item from queue.\n    # It changes front and size\n    def DeQueue(self):\n        if self.isEmpty():\n            print('Empty')\n            return\n \n        print('% s dequeued from queue' % str(self.Q[self.front]))\n        self.front = (self.front + 1) % (self.capacity)\n        self.size = self.size - 1\n \n    # Function to get front of queue\n    def que_front(self):\n        if self.isEmpty():\n            print('Queue is empty')\n \n        print('Front item is', self.Q[self.front])\n \n    # Function to get rear of queue\n    def que_rear(self):\n        if self.isEmpty():\n            print('Queue is empty')\n        print('Rear item is',  self.Q[self.rear])\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    queue = Queue(30)\n    queue.EnQueue(10)\n    queue.EnQueue(20)\n    queue.EnQueue(30)\n    queue.EnQueue(40)\n    queue.DeQueue()\n    queue.que_front()\n    queue.que_rear()\n# This code is contributed by Susobhan Akhuli\n"], "Introduction to Stack - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python program for implementation of stack \n  \n# import maxsize from sys module  \n# Used to return -infinite when stack is empty \nfrom sys import maxsize \n  \n# Function to create a stack. It initializes size of stack as 0 \ndef createStack(): \n    stack = [] \n    return stack \n  \n# Stack is empty when stack size is 0 \ndef isEmpty(stack): \n    return len(stack) == 0\n  \n# Function to add an item to stack. It increases size by 1 \ndef push(stack, item): \n    stack.append(item) \n    print(item + ' pushed to stack ') \n      \n# Function to remove an item from stack. It decreases size by 1 \ndef pop(stack): \n    if (isEmpty(stack)): \n        return str(-maxsize -1) # return minus infinite \n      \n    return stack.pop() \n  \n# Function to return the top from stack without removing it \ndef peek(stack): \n    if (isEmpty(stack)): \n        return str(-maxsize -1) # return minus infinite \n    return stack[len(stack) - 1] \n  \n# Driver program to test above functions     \nstack = createStack() \npush(stack, str(10)) \npush(stack, str(20)) \npush(stack, str(30)) \nprint(pop(stack) + ' popped from stack') \n", "# Python program for linked list implementation of stack \n  \n# Class to represent a node \n  \n  \nclass StackNode: \n  \n    # Constructor to initialize a node \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n  \nclass Stack: \n  \n    # Constructor to initialize the root of linked list \n    def __init__(self): \n        self.root = None\n  \n    def isEmpty(self): \n        return True if self.root is None else False\n  \n    def push(self, data): \n        newNode = StackNode(data) \n        newNode.next = self.root \n        self.root = newNode \n        print ('% d pushed to stack' % (data)) \n  \n    def pop(self): \n        if (self.isEmpty()): \n            return float('-inf') \n        temp = self.root \n        self.root = self.root.next\n        popped = temp.data \n        return popped \n  \n    def peek(self): \n        if self.isEmpty(): \n            return float('-inf') \n        return self.root.data \n  \n  \n# Driver code \nstack = Stack() \nstack.push(10) \nstack.push(20) \nstack.push(30) \n  \nprint ('% d popped from stack' % (stack.pop())) \nprint ('Top element is % d ' % (stack.peek())) \n  \n# This code is contributed by Nikhil Kumar Singh(nickzuck_007) \n"], "Introduction to Linked List - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Node class\nclass Node:\n \n    # Function to initialize the node object\n    def __init__(self, data):\n        self.data = data  # Assign data\n        self.next = None  # Initialize next as null\n \n# Linked List class\n \n \nclass LinkedList:\n \n    # Function to initialize the Linked List object\n    def __init__(self):\n        self.head = None\n", "# Node of a doubly linked list\nclass Node:\n    def __init__(self, next=None, prev=None, data=None):\n        self.next = next  # reference to next node in DLL\n        self.prev = prev  # reference to previous node in DLL\n        self.data = data\n"], "Insertion in Doubly Circular Linked List - GeeksforGeeks": ["# Function to insert at the end\ndef insertEnd(value):\n    global start\n \n    # If the list is empty, create a\n    # single node circular and doubly list\n    if (start == None):\n \n        new_node = Node(0)\n        new_node.data = value\n        new_node.next = new_node.prev = new_node\n        start = new_node\n        return\n \n    # If list is not empty\n \n    # Find last node */\n    last = (start).prev\n \n    # Create Node dynamically\n    new_node = Node(0)\n    new_node.data = value\n \n    # Start is going to be next of new_node\n    new_node.next = start\n \n    # Make new node previous of start\n    (start).prev = new_node\n \n    # Make last previous of new node\n    new_node.prev = last\n \n    # Make new node next of old last\n    last.next = new_node\n \n    # This code is contributed by shivanisinghss2110\n", "# Function to insert Node at the beginning\n# of the List,\n \n \ndef insertBegin(value):\n    global start\n \n    # Pointer points to last Node\n    last = (start).prev\n \n    new_node = Node(0)\n    new_node.data = value  # Inserting the data\n \n    # setting up previous and\n    # next of new node\n    new_node.next = start\n    new_node.prev = last\n \n    # Update next and previous pointers\n    # of start and last.\n    last.next = (start).prev = new_node\n \n    # Update start pointer\n    start = new_node\n \n    # This code is contributed by shivanisinghss2110\n", "# Function to insert node with value as value1.\n# The new node is inserted after the node with\n# with value2\n \n \ndef insertAfter(value1, value2):\n    global start\n    new_node = Node(0)\n    new_node.data = value1  # Inserting the data\n \n    # Find node having value2 and\n    # next node of it\n    temp = start\n    while (temp.data != value2):\n        temp = temp.next\n    next = temp.next\n \n    # insert new_node between temp and next.\n    temp.next = new_node\n    new_node.prev = temp\n    new_node.next = next\n    next.prev = new_node\n \n# this code is contributed by shivanisinghss2110\n", "# Python3 program to illustrate inserting\n# a Node in a Circular Doubly Linked list\n# in begging, end and middle\n \n# Structure of a Node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n \n# Function to insert at the end\n \n \ndef insertEnd(value):\n    global start\n \n    # If the list is empty, create a\n    # single node circular and doubly list\n    if (start == None):\n \n        new_node = Node(0)\n        new_node.data = value\n        new_node.next = new_node.prev = new_node\n        start = new_node\n        return\n \n    # If list is not empty\n \n    # Find last node */\n    last = (start).prev\n \n    # Create Node dynamically\n    new_node = Node(0)\n    new_node.data = value\n \n    # Start is going to be next of new_node\n    new_node.next = start\n \n    # Make new node previous of start\n    (start).prev = new_node\n \n    # Make last previous of new node\n    new_node.prev = last\n \n    # Make new node next of old last\n    last.next = new_node\n \n# Function to insert Node at the beginning\n# of the List,\n \n \ndef insertBegin(value):\n    global start\n \n    # Pointer points to last Node\n    last = (start).prev\n \n    new_node = Node(0)\n    new_node.data = value  # Inserting the data\n \n    # setting up previous and\n    # next of new node\n    new_node.next = start\n    new_node.prev = last\n \n    # Update next and previous pointers\n    # of start and last.\n    last.next = (start).prev = new_node\n \n    # Update start pointer\n    start = new_node\n \n# Function to insert node with value as value1.\n# The new node is inserted after the node with\n# with value2\n \n \ndef insertAfter(value1, value2):\n    global start\n    new_node = Node(0)\n    new_node.data = value1  # Inserting the data\n \n    # Find node having value2 and\n    # next node of it\n    temp = start\n    while (temp.data != value2):\n        temp = temp.next\n    next = temp.next\n \n    # insert new_node between temp and next.\n    temp.next = new_node\n    new_node.prev = temp\n    new_node.next = next\n    next.prev = new_node\n \n \ndef display():\n    global start\n    temp = start\n \n    print('Traversal in forward direction:')\n    while (temp.next != start):\n \n        print(temp.data, end=' ')\n        temp = temp.next\n \n    print(temp.data)\n \n    print('Traversal in reverse direction:')\n    last = start.prev\n    temp = last\n    while (temp.prev != last):\n \n        print(temp.data, end=' ')\n        temp = temp.prev\n \n    print(temp.data)\n \n \n# Driver Code\nif __name__ == '__main__':\n    global start\n \n    # Start with the empty list\n    start = None\n \n    # Insert 5. So linked list becomes 5.None\n    insertEnd(5)\n \n    # Insert 4 at the beginning. So linked\n    # list becomes 4.5\n    insertBegin(4)\n \n    # Insert 7 at the end. So linked list\n    # becomes 4.5.7\n    insertEnd(7)\n \n    # Insert 8 at the end. So linked list\n    # becomes 4.5.7.8\n    insertEnd(8)\n \n    # Insert 6, after 5. So linked list\n    # becomes 4.5.6.7.8\n    insertAfter(6, 5)\n \n    print('Created circular doubly linked list is: ')\n    display()\n \n# This code is contributed by Arnab kundu\n"], "Introduction to Circular Linked List - GeeksforGeeks": ["# Class Node, similar to the linked list \nclass Node: \n    def __init__(self,data): \n        self.data = data \n        self.next = None\n", "# Initialize the Nodes. \none = Node(3) \ntwo = Node(5) \nthree = Node(9) \n  \n# Connect nodes \none.next = two \ntwo.next = three \nthree.next = one\n", "# Python program to delete a given key from linked list \nclass Node: \n    def __init__(self, data): \n        self.data = data \n        self.next = None\n  \n# Function to insert a node at the \n# beginning of a Circular linked list \n  \n  \ndef push(head, data): \n    # Create a new node and make head as next of it. \n    newP = Node(data) \n    newP.next = head \n  \n    # If linked list is not NULL then \n    # set the next of last node \n    if head != None: \n        # Find the node before head and \n        # update next of it. \n        temp = head \n        while (temp.next != head): \n            temp = temp.next\n        temp.next = newP \n    else: \n        newP.next = newP \n    head = newP \n    return head \n  \n# Function to print nodes in a given circular linked list \n  \n  \ndef printList(head): \n    if head == None: \n        print('List is Empty') \n        return\n    temp = head.next\n    print(head.data, end=' ') \n    if (head != None): \n        while (temp != head): \n            print(temp.data, end=' ') \n            temp = temp.next\n    print() \n  \n# Function to delete a given node \n# from the list \n  \n  \ndef deleteNode(head, key): \n    # If linked list is empty \n    if (head == None): \n        return\n  \n    # If the list contains only a \n    # single node \n    if (head.data == key and head.next == head): \n        head = None\n        return\n  \n    last = head \n  \n    # If head is to be deleted \n    if (head.data == key): \n        # Find the last node of the list \n        while (last.next != head): \n            last = last.next\n  \n        # Point last node to the next of \n        # head i.e. the second node \n        # of the list \n        last.next = head.next\n        head = last.next\n        return\n  \n    # Either the node to be deleted is \n    # not found or the end of list \n    # is not reached \n    while (last.next != head and last.next.data != key): \n        last = last.next\n  \n    # If node to be deleted was found \n    if (last.next.data == key): \n        d = last.next\n        last.next = d.next\n        d = None\n    else: \n        print('Given node is not found in the list!!!') \n  \n  \n# Driver code \n# Initialize lists as empty \nhead = None\n  \n# Created linked list will be \n# 2->5->7->8->10 \nhead = push(head, 2) \nhead = push(head, 5) \nhead = push(head, 7) \nhead = push(head, 8) \nhead = push(head, 10) \n  \nprint('List Before Deletion: ') \nprintList(head) \n  \ndeleteNode(head, 7) \nprint('List After Deletion: ') \nprintList(head) \n"], "Insertion in a Doubly Linked List - GeeksforGeeks": ["# Adding a node at the front of the list\ndef push(self, new_data):\n \n    # 1 & 2: Allocate the Node & Put in the data\n    new_node = Node(data=new_data)\n \n    # 3. Make next of new node as head and previous as NULL\n    new_node.next = self.head\n    new_node.prev = None\n \n    # 4. change prev of head node to new node\n    if self.head is not None:\n        self.head.prev = new_node\n \n    # 5. move the head to point to the new node\n    self.head = new_node\n \n# This code is contributed by jatinreaper\n", "# Given a node as prev_node, insert\n# a new node after the given node\n \n \ndef insertAfter(self, prev_node, new_data):\n \n    # Check if the given prev_node is NULL\n    if prev_node is None:\n        print('This node doesn't exist in DLL')\n        return\n \n    # 1. allocate node  & \n    # 2. put in the data\n    new_node = Node(data=new_data)\n \n    # 3. Make next of new node as next of prev_node\n    new_node.next = prev_node.next\n \n    # 4. Make the next of prev_node as new_node\n    prev_node.next = new_node\n \n    # 5. Make prev_node as previous of new_node\n    new_node.prev = prev_node\n \n    # 6. Change previous of new_node's next node\n    if new_node.next is not None:\n        new_node.next.prev = new_node\n \n#  This code is contributed by jatinreaper\n", "# Given a node as prev_node, insert\n# a new node after the given node\n \n \ndef insertAfter(self, next_node, new_data):\n \n    # Check if the given next_node is NULL\n    if next_node is None:\n        print('This node doesn't exist in DLL')\n        return\n \n    # 1. Allocate node  & \n    # 2. Put in the data\n    new_node = Node(data=new_data)\n \n    # 3. Make previous of new node as previous of prev_node\n    new_node.prev = next_node.prev\n \n    # 4. Make the previous of next_node as new_node\n    next_node.prev = new_node\n \n    # 5. Make next_node as next of new_node\n    new_node.next = next_node\n \n    # 6. Change next of new_node's previous node\n    if new_node.prev is not None:\n        new_node.prev.next = new_node\n    else:\n        head = new_node\n \n#  This code is contributed by jatinreaper\n", "# Add a node at the end of the DLL\ndef append(self, new_data):\n \n    # 1. allocate node \n    # 2. put in the data\n    new_node = Node(data=new_data)\n    last = self.head\n \n    # 3. This new node is going to be the\n    # last node, so make next of it as NULL\n    new_node.next = None\n \n    # 4. If the Linked List is empty, then\n    #  make the new node as head\n    if self.head is None:\n        new_node.prev = None\n        self.head = new_node\n        return\n \n    # 5. Else traverse till the last node\n    while (last.next is not None):\n        last = last.next\n \n    # 6. Change the next of last node\n    last.next = new_node\n    # 7. Make last node as previous of new node */\n    new_node.prev = last\n \n#  This code is contributed by jatinreaper\n"], "Implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Return 0 / 1 ( 0 for false, 1 for true ) for this problem Problem Constraints 1 <= |A| <= 5 * 103 1 <= |B| <= 5 * 103 Input Format The first argument is a string A. The second argument is a string A. Output Format Return an integer, 0 / 1 ( 0 for false, 1 for true ) for this problem Example Input isMatch(\"aa\",\"a\") \u2192 0 isMatch(\"aa\",\"aa\") \u2192 1 isMatch(\"aaa\",\"aa\") \u2192 0 isMatch(\"aa\", \"a*\") \u2192 1 isMatch(\"aa\", \".*\") \u2192 1 isMatch(\"ab\", \".*\") \u2192 1 isMatch(\"aab\", \"c*a*b\") \u2192 1": "import sys\nsys.setrecursionlimit(15000000)\nclass Solution:\n    # @param A : string\n    # @param B : string\n    # @return an integer\n    def isMatch(self, A, B):\n\n        cache = {}\n\n        def dfs(i, j):\n            if (i,j) in cache:\n                return cache[(i,j)]\n            if i >= len(A) and j >= len(B):\n                return True\n            if j >= len(B):\n                return False\n\n            match =  i < len(A) and (A[i] == B[j] or B[j] == \".\")\n\n            if (j+1) < len(B) and B[j+1] == \"*\":\n                cache[(i,j)] = dfs(i, j+2) or (match and dfs(i+1, j))\n                return cache[(i,j)]\n            if match:\n                cache[(i,j)] = dfs(i+1, j+1)\n                return cache[(i,j)]\n            cache[(i,j)] = False\n            return False\n        \n        return int(dfs(0, 0))\n\n\n", "Bucket Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks": ["# Python3 program to sort an array\n# using bucket sort\n \n \ndef insertionSort(b):\n    for i in range(1, len(b)):\n        up = b[i]\n        j = i - 1\n        while j >= 0 and b[j] > up:\n            b[j + 1] = b[j]\n            j -= 1\n        b[j + 1] = up\n    return b\n \n \ndef bucketSort(x):\n    arr = []\n    slot_num = 10  # 10 means 10 slots, each\n    # slot's size is 0.1\n    for i in range(slot_num):\n        arr.append([])\n \n    # Put array elements in different buckets\n    for j in x:\n        index_b = int(slot_num * j)\n        arr[index_b].append(j)\n \n    # Sort individual buckets\n    for i in range(slot_num):\n        arr[i] = insertionSort(arr[i])\n \n    # concatenate the result\n    k = 0\n    for i in range(slot_num):\n        for j in range(len(arr[i])):\n            x[k] = arr[i][j]\n            k += 1\n    return x\n \n \n# Driver Code\nx = [0.897, 0.565, 0.656,\n     0.1234, 0.665, 0.3434]\nprint('Sorted Array is')\nprint(bucketSort(x))\n \n# This code is contributed by\n# Oneil Hsiao\n"], "Radix Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks": ["# Python program for implementation of Radix Sort\n# A function to do counting sort of arr[] according to\n# the digit represented by exp.\n \n \ndef countingSort(arr, exp1):\n \n    n = len(arr)\n \n    # The output array elements that will have sorted arr\n    output = [0] * (n)\n \n    # initialize count array as 0\n    count = [0] * (10)\n \n    # Store count of occurrences in count[]\n    for i in range(0, n):\n        index = arr[i] // exp1\n        count[index % 10] += 1\n \n    # Change count[i] so that count[i] now contains actual\n    # position of this digit in output array\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n \n    # Build the output array\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp1\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n \n    # Copying the output array to arr[],\n    # so that arr now contains sorted numbers\n    i = 0\n    for i in range(0, len(arr)):\n        arr[i] = output[i]\n \n# Method to do Radix Sort\n \n \ndef radixSort(arr):\n \n    # Find the maximum number to know number of digits\n    max1 = max(arr)\n \n    # Do counting sort for every digit. Note that instead\n    # of passing digit number, exp is passed. exp is 10^i\n    # where i is current digit number\n    exp = 1\n    while max1 / exp >= 1:\n        countingSort(arr, exp)\n        exp *= 10\n \n \n# Driver code\narr = [170, 45, 75, 90, 802, 24, 2, 66]\n \n# Function Call\nradixSort(arr)\n \nfor i in range(len(arr)):\n    print(arr[i], end=' ')\n \n# This code is contributed by Mohit Kumra\n# Edited by Patrick Gallagher\n"], "Counting Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks": ["def count_sort(input_array):\n    # Finding the maximum element of input_array.\n    M = max(input_array)\n \n    # Initializing count_array with 0\n    count_array = [0] * (M + 1)\n \n    # Mapping each element of input_array as an index of count_array\n    for num in input_array:\n        count_array[num] += 1\n \n    # Calculating prefix sum at every index of count_array\n    for i in range(1, M + 1):\n        count_array[i] += count_array[i - 1]\n \n    # Creating output_array from count_array\n    output_array = [0] * len(input_array)\n \n    for i in range(len(input_array) - 1, -1, -1):\n        output_array[count_array[input_array[i]] - 1] = input_array[i]\n        count_array[input_array[i]] -= 1\n \n    return output_array\n \n# Driver code\nif __name__ == '__main__':\n    # Input array\n    input_array = [4, 3, 12, 1, 5, 5, 3, 9]\n \n    # Output array\n    output_array = count_sort(input_array)\n \n    for num in output_array:\n        print(num, end=' ')\n"], "Heap Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks": ["# Python program for implementation of heap Sort\n \n# To heapify subtree rooted at index i.\n# n is size of heap\n \n \ndef heapify(arr, N, i):\n    largest = i  # Initialize largest as root\n    l = 2 * i + 1     # left = 2*i + 1\n    r = 2 * i + 2     # right = 2*i + 2\n \n    # See if left child of root exists and is\n    # greater than root\n    if l < N and arr[largest] < arr[l]:\n        largest = l\n \n    # See if right child of root exists and is\n    # greater than root\n    if r < N and arr[largest] < arr[r]:\n        largest = r\n \n    # Change root, if needed\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n \n        # Heapify the root.\n        heapify(arr, N, largest)\n \n# The main function to sort an array of given size\n \n \ndef heapSort(arr):\n    N = len(arr)\n \n    # Build a maxheap.\n    for i in range(N//2 - 1, -1, -1):\n        heapify(arr, N, i)\n \n    # One by one extract elements\n    for i in range(N-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        heapify(arr, i, 0)\n \n \n# Driver's code\nif __name__ == '__main__':\n    arr = [12, 11, 13, 5, 6, 7]\n \n    # Function call\n    heapSort(arr)\n    N = len(arr)\n \n    print('Sorted array is')\n    for i in range(N):\n        print('%d' % arr[i], end=' ')\n# This code is contributed by Mohit Kumra\n"], "QuickSort - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python3 implementation of QuickSort\n \n \n# Function to find the partition position\ndef partition(array, low, high):\n \n    # Choose the rightmost element as pivot\n    pivot = array[high]\n \n    # Pointer for greater element\n    i = low - 1\n \n    # Traverse through all elements\n    # compare each element with pivot\n    for j in range(low, high):\n        if array[j] <= pivot:\n \n            # If element smaller than pivot is found\n            # swap it with the greater element pointed by i\n            i = i + 1\n \n            # Swapping element at i with element at j\n            (array[i], array[j]) = (array[j], array[i])\n \n    # Swap the pivot element with\n    # the greater element specified by i\n    (array[i + 1], array[high]) = (array[high], array[i + 1])\n \n    # Return the position from where partition is done\n    return i + 1\n \n \n# Function to perform quicksort\ndef quicksort(array, low, high):\n    if low < high:\n \n        # Find pivot element such that\n        # element smaller than pivot are on the left\n        # element greater than pivot are on the right\n        pi = partition(array, low, high)\n \n        # Recursive call on the left of pivot\n        quicksort(array, low, pi - 1)\n \n        # Recursive call on the right of pivot\n        quicksort(array, pi + 1, high)\n \n \n# Driver code\nif __name__ == '__main__':\n    array = [10, 7, 8, 9, 1, 5]\n    N = len(array)\n \n    # Function call\n    quicksort(array, 0, N - 1)\n    print('Sorted array:')\n    for x in array:\n        print(x, end=' ')\n \n# This code is contributed by Adnan Aliakbar\n"], "Merge Sort - Data Structure and Algorithms Tutorials - GeeksforGeeks": ["# Python program for implementation of MergeSort\n \n \ndef mergeSort(arr):\n    if len(arr) > 1:\n \n         # Finding the mid of the array\n        mid = len(arr)//2\n \n        # Dividing the array elements\n        L = arr[:mid]\n \n        # Into 2 halves\n        R = arr[mid:]\n \n        # Sorting the first half\n        mergeSort(L)\n \n        # Sorting the second half\n        mergeSort(R)\n \n        i = j = k = 0\n \n        # Copy data to temp arrays L[] and R[]\n        while i < len(L) and j < len(R):\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n            k += 1\n \n        # Checking if any element was left\n        while i < len(L):\n            arr[k] = L[i]\n            i += 1\n            k += 1\n \n        while j < len(R):\n            arr[k] = R[j]\n            j += 1\n            k += 1\n \n \n# Code to print the list\ndef printList(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=' ')\n    print()\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [12, 11, 13, 5, 6, 7]\n    print('Given array is')\n    printList(arr)\n    mergeSort(arr)\n    print('\\nSorted array is ')\n    printList(arr)\n \n# This code is contributed by Mayank Khanna\n"], "Insertion Sort - Data Structure and Algorithm Tutorials - GeeksforGeeks": [], "Bubble Sort - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Optimized Python program for implementation of Bubble Sort\n \n \ndef bubbleSort(arr):\n    n = len(arr)\n     \n    # Traverse through all array elements\n    for i in range(n):\n        swapped = False\n \n        # Last i elements are already in place\n        for j in range(0, n-i-1):\n \n            # Traverse the array from 0 to n-i-1\n            # Swap if the element found is greater\n            # than the next element\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if (swapped == False):\n            break\n \n \n# Driver code to test above\nif __name__ == '__main__':\n    arr = [64, 34, 25, 12, 22, 11, 90]\n \n    bubbleSort(arr)\n \n    print('Sorted array:')\n    for i in range(len(arr)):\n        print('%d' % arr[i], end=' ')\n \n# This code is modified by Suraj krushna Yadav\n"], "Selection Sort \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python program for implementation of Selection\n# Sort\nimport sys\nA = [64, 25, 12, 22, 11]\n \n# Traverse through all array elements\nfor i in range(len(A)):\n     \n    # Find the minimum element in remaining \n    # unsorted array\n    min_idx = i\n    for j in range(i+1, len(A)):\n        if A[min_idx] > A[j]:\n            min_idx = j\n             \n    # Swap the found minimum element with \n    # the first element        \n    A[i], A[min_idx] = A[min_idx], A[i]\n \n# Driver code to test above\nprint ('Sorted array')\nfor i in range(len(A)):\n    print('%d' %A[i],end=' , ') \n"], "Binary Search - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python3 code to implement iterative Binary\n# Search.\n \n \n# It returns location of x in given array arr\ndef binarySearch(arr, l, r, x):\n \n    while l <= r:\n \n        mid = l + (r - l) // 2\n \n        # Check if x is present at mid\n        if arr[mid] == x:\n            return mid\n \n        # If x is greater, ignore left half\n        elif arr[mid] < x:\n            l = mid + 1\n \n        # If x is smaller, ignore right half\n        else:\n            r = mid - 1\n \n    # If we reach here, then the element\n    # was not present\n    return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n \n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n    if result != -1:\n        print('Element is present at index', result)\n    else:\n        print('Element is not present in array')\n", "# Python3 Program for recursive binary search.\n \n \n# Returns index of x in arr if present, else -1\ndef binarySearch(arr, l, r, x):\n \n    # Check base case\n    if r >= l:\n \n        mid = l + (r - l) // 2\n \n        # If element is present at the middle itself\n        if arr[mid] == x:\n            return mid\n \n        # If element is smaller than mid, then it\n        # can only be present in left subarray\n        elif arr[mid] > x:\n            return binarySearch(arr, l, mid-1, x)\n \n        # Else the element can only be present\n        # in right subarray\n        else:\n            return binarySearch(arr, mid + 1, r, x)\n \n    # Element is not present in the array\n    else:\n        return -1\n \n \n# Driver Code\nif __name__ == '__main__':\n    arr = [2, 3, 4, 10, 40]\n    x = 10\n     \n    # Function call\n    result = binarySearch(arr, 0, len(arr)-1, x)\n     \n    if result != -1:\n        print('Element is present at index', result)\n    else:\n        print('Element is not present in array')\n"], "Linear Search Algorithm - Data Structure and Algorithms Tutorials - GeeksforGeeks": ["# Python3 code to linearly search x in arr[]. \n  \n  \ndef search(arr, N, x): \n  \n    for i in range(0, N): \n        if (arr[i] == x): \n            return i \n    return -1\n  \n  \n# Driver Code \nif __name__ == '__main__': \n    arr = [2, 3, 4, 10, 40] \n    x = 10\n    N = len(arr) \n  \n    # Function call \n    result = search(arr, N, x) \n    if(result == -1): \n        print('Element is not present in array') \n    else: \n        print('Element is present at index', result) \n"], "Worst, Average and Best Case Analysis of Algorithms - GeeksforGeeks": ["# Python 3 implementation of the approach\n \n# Linearly search x in arr[]. If x is present\n# then return the index, otherwise return -1\n \n \ndef search(arr, x):\n    for index, value in enumerate(arr):\n        if value == x:\n            return index\n    return -1\n \n \n# Driver's Code\nif __name__ == '__main__':\n    arr = [1, 10, 30, 15]\n    x = 30\n \n    # Function call\n    print(x, 'is present at index',\n          search(arr, x))\n", "# Python 3 implementation of the approach\n \n \ndef getsum(arr, n):\n    if n % 2 == 0:  # if (n) is even\n        return 0\n \n    Sum = 0\n    for i in range(n):\n        Sum += arr[i]\n    return Sum  # if (n) is odd\n \n \n# Driver's Code\nif __name__ == '__main__':\n  arr1 = [1, 2, 3, 4]  # Declaring an array of even length\n  n1 = len(arr1)\n  arr2 = [1, 2, 3, 4, 5]  # Declaring an array of odd length\n  n2 = len(arr2)\n \n# Function call\nprint(getsum(arr1, n1))  # print 0 because (n) is even\n \nprint(getsum(arr2, n2))  # print sum of array because (n) is odd\n \n# This code is contributed by Syed Maruf Ali\n"], "Given an array of non-negative integers, A, you are initially positioned at the 0th index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Input Format: The first and the only argument of input will be an integer array A. Output Format: Return an integer, representing the answer as described in the problem statement. => 0 : If you cannot reach the last index. => 1 : If you can reach the last index. Constraints: 1 <= len(A) <= 106 0 <= A[i] <= 30 Examples: Input 1: A = [2,3,1,1,4] Output 1: 1 Explanation 1: Index 0 -> Index 2 -> Index 3 -> Index 4 Input 2: A = [3,2,1,0,4] Output 2: 0 Explanation 2: There is no possible path to reach the last index.": "class Solution:\n    # @param A : list of integers\n    # @return an integer\n    def canJump(self, a):\n        \n        # This variable denotes the maximum array elem we can jump\n        # initially it is zero\n        max_jump = 0\n        for i in range(len(a)):\n            # If this index not reachable than return 0\n            if i > max_jump:\n                return 0\n            #update max jump\n            max_jump = max(max_jump, i + a[i])\n        return 1\n\n\n\n", "What is Algorithm | Introduction to Algorithms - GeeksforGeeks": ["# Python3 program to add three numbers\n# with the help of above designed\n# algorithm\n \n \nif __name__ == '__main__':\n \n    # Variables to take the input of\n    # the 3 numbers\n    num1 = num2 = num3 = 0\n \n    # Variable to store the resultant sum\n    sum = 0\n \n    # Take the 3 numbers as input\n    num1 = int(input('Enter the 1st number: '))\n \n    num2 = int(input('Enter the 2nd number: '))\n \n    num3 = int(input('Enter the 3rd number: '))\n \n    # Calculate the sum using + operator\n    # and store it in variable sum\n    sum = num1 + num2 + num3\n \n    # Print the sum\n    print('\\nSum of the 3 numbers is:', sum)\n"], "Introduction to Bitwise Algorithms - Data Structures and Algorithms Tutorial - GeeksforGeeks": ["a = 7\nb = 4\nresult = a & b\nprint(result)\n# This code is contributed by akashish__\n", "a = 12\nb = 25\nresult = a | b\nprint(result)\n \n# This code is contributed by garg28harsh.\n", "a = 12\nb = 25\nresult = a ^ b\nprint(result)\n \n# This code is contributed by garg28harsh.\n", "a = 0\nprint('Value of a without using NOT operator: ' , a)\nprint('Inverting using NOT operator (with sign bit): ' , (~a))\nprint('Inverting using NOT operator (without sign bit): ' , int(not(a)))\n#  This code is contributed by akashish__\n", "# Python code for the above approach\n \nnum1 = 1024\n \nbt1 = bin(num1)[2:].zfill(32)\nprint(bt1)\n \nnum2 = num1 << 1\nbt2 = bin(num2)[2:].zfill(32)\nprint(bt2)\n \nnum3 = num1 << 2\nbitset13 = bin(num3)[2:].zfill(16)\nprint(bitset13)\n \n# This code is contributed by Prince Kumar\n", "# num = number, pos = position at which we want to set the bit\ndef set(num, pos):\n    # First step = Shift '1'\n    # Second step = Bitwise OR\n    num |= (1 << pos)\n    print(num)\n \n \nnum, pos = 4, 1\n \nset(num, pos)\n \n# This code is contributed by sarajadhav12052009\n", "# First Step: Getting which have all '1's except the\n# given position\n \n \ndef unset(num, pos):\n    # Second Step: Bitwise AND this number with the given number\n    num &= (~(1 << pos))\n    print(num)\n \n \nnum, pos = 7, 1\n \nunset(num, pos)\n", "def toggle(num, pos):\n    # First Step: Shifts '1'\n    # Second Step: XOR num\n    num ^= (1 << pos)\n    print(num)\n \n \nnum, pos = 4, 1\n \ntoggle(num, pos)\n \n# This code is contributed by sarajadhav12052009\n", "# code\ndef at_position(num, pos):\n    bit = num & (1 << pos)\n    return bit\n \n \nnum = 5\npos = 0\nbit = at_position(num, pos)\nprint(bit)\n", "# Python program for the above approach\n \nnum = 12\nans = num << 1\nprint(ans)\n \n# This code is contributed by Shubham Singh\n", "# Python program for the above approach\n \nnum = 12\nans = num >> 1\nprint(ans)\n \n# This code is contributed by Shubham Singh\n", "def countBits(n):\n    # Initializing a variable count to 0\n    count = 0\n    while n:\n        # If the last bit is 1, count will be incremented by 1 in this step.\n        count += n & 1\n        # Using the right shift operator. The bits will be shifted one position to the right.\n        n >>= 1\n    return count\n"], "Introduction to Divide and Conquer Algorithm - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# Python3 code to demonstrate Divide and\n# Conquer Algorithm\n \n# Function to find the maximum no.\n# in a given array.\n \n \ndef DAC_Max(a, index, l):\n    max = -1\n    if(l - 1 == 0):\n        return arr[index]\n    if (index >= l - 2):\n        if (a[index] > a[index + 1]):\n            return a[index]\n        else:\n            return a[index + 1]\n \n    # Logic to find the Maximum element\n    # in the given array.\n    max = DAC_Max(a, index + 1, l)\n \n    if (a[index] > max):\n        return a[index]\n    else:\n        return max\n \n# Function to find the minimum no.\n# in a given array.\n \n \ndef DAC_Min(a, index, l):\n    min = 0\n    if(l - 1 == 0):\n        return arr[index]\n    if (index >= l - 2):\n        if (a[index] < a[index + 1]):\n            return a[index]\n        else:\n            return a[index + 1]\n \n    # Logic to find the Minimum element\n    # in the given array.\n    min = DAC_Min(a, index + 1, l)\n \n    if (a[index] < min):\n        return a[index]\n    else:\n        return min\n \n \n# Driver Code\nif __name__ == '__main__':\n \n    # Defining the variables\n    min, max = 0, -1\n \n    # Initializing the array\n    a = [70, 250, 50, 80, 140, 12, 14]\n \n    # Recursion - DAC_Max function called\n    max = DAC_Max(a, 0, 7)\n \n    # Recursion - DAC_Max function called\n    min = DAC_Min(a, 0, 7)\n    print('The minimum number in a given array is : ', min)\n    print('The maximum number in a given array is : ', max)\n \n# This code is contributed by 29AjayKumar\n"], "Introduction to Recursion - Data Structure and Algorithm Tutorials - GeeksforGeeks": ["# A Python 3 program to\n# demonstrate working of\n# recursion\n \n \ndef printFun(test):\n \n    if (test < 1):\n        return\n    else:\n \n        print(test, end=' ')\n        printFun(test-1)  # statement 2\n        print(test, end=' ')\n        return\n \n# Driver Code\ntest = 3\nprintFun(test)\n \n# This code is contributed by\n# Smitha Dinesh Semwal\n", "# Python code to implement Fibonacci series\n \n# Function for fibonacci\ndef fib(n):\n \n    # Stop condition\n    if (n == 0):\n        return 0\n \n    # Stop condition\n    if (n == 1 or n == 2):\n        return 1\n \n    # Recursion function\n    else:\n        return (fib(n - 1) + fib(n - 2))\n \n \n# Driver Code\n \n# Initialize variable n.\nn = 5;\nprint('Fibonacci series of 5 numbers is :',end=' ')\n \n# for loop to print the fibonacci series.\nfor i in range(0,n): \n    print(fib(i),end=' ')\n", "# Python3 code to implement factorial\n \n# Factorial function\ndef f(n):\n \n    # Stop condition\n    if (n == 0 or n == 1):\n        return 1;\n \n    # Recursive condition\n    else:\n        return n * f(n - 1);\n \n \n# Driver code\nif __name__=='__main__':\n \n    n = 5;\n    print('factorial of',n,'is:',f(n))\n     \n    # This code is contributed by pratham76.\n", "def factorial(n):\n    # Base case: if n is 0 or 1, return 1\n    if n == 0 or n == 1:\n        return 1\n \n    # Recursive case: if n is greater than 1, call the function with n-1 and multiply by n\n    else:\n        return n * factorial(n-1)\n \n# Call the factorial function and print the result\nresult = factorial(5)\nprint(result)  # Output: 120\n"], "Introduction to Pattern Searching - Data Structure and Algorithm Tutorial - GeeksforGeeks": ["# Python program for above approach \ndef search(pat, txt): \n    M = len(pat) \n    N = len(txt) \n    for i in range(N-M): \n        for j in range(M): \n            k = j+1\n            if(txt[i+j] != pat[j]): \n                break\n        if(k == M): \n            print('Pattern found at index ', i) \n  \ntxt = 'AABAACAADAABAAABAA'\npat = 'AABA'\nsearch(pat, txt) \n  \n# This code is contributed by ishankhandelwals.\n", "# Python program for implementation of KMP pattern searching \n# algorithm \ndef computeLPSArray(pat, M, lps): \n    len = 0  # length of the previous longest prefix suffix \n  \n    lps[0]  # lps[0] is always 0 \n    i = 1\n  \n    # the loop calculates lps[i] for i = 1 to M-1 \n    while i < M: \n        if pat[i] == pat[len]: \n            len += 1\n            lps[i] = len\n            i += 1\n        else: \n            # This is tricky. Consider the example. \n            # AAACAAAA and i = 7. The idea is similar \n            # to search step. \n            if len != 0: \n                len = lps[len-1] \n  \n            # Also, note that we do not increment i here \n            else: \n                lps[i] = 0\n                i += 1\n  \ndef KMPSearch(pat, txt): \n    M = len(pat) \n    N = len(txt) \n  \n    # create lps[] that will hold the longest prefix suffix \n    # values for pattern \n    lps = [0]*M \n    j = 0  # index for pat[] \n  \n    # Preprocess the pattern (calculate lps[] array) \n    computeLPSArray(pat, M, lps) \n  \n    i = 0  # index for txt[] \n    while (N - i) >= (M - j): \n        if pat[j] == txt[i]: \n            j += 1\n            i += 1\n  \n        if j == M: \n            print('Found pattern at index:', i-j) \n            j = lps[j-1] \n  \n        # mismatch after j matches \n        elif i < N and pat[j] != txt[i]: \n            # Do not match lps[0..lps[j-1]] characters, \n            # they will match anyway \n            if j != 0: \n                j = lps[j-1] \n            else: \n                i += 1\n  \ntxt = 'ABABDABACDABABCABAB'\npat = 'ABABCABAB'\nKMPSearch(pat, txt) \n  \n# This code is contributed by ishankhandelwals.\n", "# d is the number of characters in the input alphabet \nd = 256\n  \n''' pat -> pattern \ntxt -> text \nq -> A prime number '''\ndef search(pat, txt, q): \n      \n    M = len(pat) \n    N = len(txt) \n    p = 0 # hash value for pattern \n    t = 0 # hash value for txt \n    h = 1\n  \n    # The value of h would be 'pow(d, M-1)%q' \n    for i in range(M - 1): \n        h = (h * d) % q \n  \n    # Calculate the hash value of pattern and first \n    # window of text \n    for i in range(M): \n        p = (d * p + ord(pat[i])) % q \n        t = (d * t + ord(txt[i])) % q \n  \n    # Slide the pattern over text one by one \n    for i in range(N - M + 1): \n        # Check the hash values of current window of text \n        # and pattern. If the hash values match then only \n        # check for characters one by one \n        if p == t: \n            # Check for characters one by one \n            for j in range(M): \n                if txt[i + j] != pat[j]: \n                    break\n            # if p == t and pat[0...M-1] = txt[i, i+1, \n            # ...i+M-1] \n            if j == M - 1: \n                print('Pattern found at index ' + str(i)) \n  \n        # Calculate hash value for next window of text: \n        # Remove leading digit, add trailing digit \n        if i < N - M: \n            t = (d * (t - ord(txt[i]) * h) + ord(txt[i + M])) % q \n            # We might get negative value of t, converting \n            # it to positive \n            if t < 0: \n                t = (t + q) \n  \n# Driver code \ntxt = 'GEEKS FOR GEEKS'\npat = 'GEEK'\n  \n# we mod to avoid overflowing of value but we should \n# take as big q as possible to avoid the collison \nq = float('inf') \n  \n# Function Call \nsearch(pat, txt, q) \n  \n# This code is contributed by akashish__ \n", "# A Python program that implements Z algorithm for pattern \n# searching \n# Fills Z array for given string str[] \ndef getZarr(string, Z): \n    n = len(string) \n      \n    # [L, R] make a window which matches with prefix of s \n    L, R, k = 0, 0, 0\n    Z[0] = n \n  \n    for i in range(1, n): \n        \n      # if i>R nothing matches so we will calculate. \n        # Z[i] using naive way. \n        if i > R: \n            L, R = i, i \n              \n            # R-L = 0 in starting, so it will start \n            # checking from 0'th index. For example, \n            # for 'ababab' and i = 1, the value of R \n            # remains 0 and Z[i] becomes 0. For string \n            # 'aaaaaa' and i = 1, Z[i] and R become 5 \n            while R < n and string[R - L] == string[R]: \n                R += 1\n            Z[i] = R - L \n            R -= 1\n        else: \n            \n          # k = i-L so k corresponds to number which \n            # matches in [L, R] interval. \n            k = i - L \n              \n            # if Z[k] is less than remaining interval \n            # then Z[i] will be equal to Z[k]. \n            # For example, str = 'ababab', i = 3, R = 5 \n            # and L = 2 \n            if Z[k] < R - i + 1: \n                Z[i] = Z[k] \n                  \n            # For example str = 'aaaaaa' and i = 2, R is 5, \n            # L is 0 \n            else: \n                \n              # else start from R and check manually \n                L = i \n                while R < n and string[R - L] == string[R]: \n                    R += 1\n                Z[i] = R - L \n                R -= 1\n                  \n# prints all occurrences of pattern in text using Z algo \ndef search(text, pattern): \n    \n  # Create concatenated string 'P$T' \n    concat = pattern + '$' + text \n    l = len(concat) \n  \n    # Construct Z array \n    Z = [0] * l \n    getZarr(concat, Z) \n  \n    # now looping through Z array for matching condition \n    for i in range(l): \n        \n      # if Z[i] (matched region) is equal to pattern \n        # length we got the pattern \n        if Z[i] == len(pattern): \n            print('Pattern found at index', i - len(pattern) - 1) \n  \n# Driver program \nif __name__ == '__main__': \n    text = 'GEEKS FOR GEEKS'\n    pattern = 'GEEK'\n    search(text, pattern) \n      \n# This code is contributed by akashish__ \n"], "Dynamic Programming (DP) Tutorial with Problems - GeeksforGeeks": ["# Python program to Returns the number of arrangements to form 'n'\ndef solve(n):\n  # Base case\n    if(n < 0):\n        return 0\n    if(n == 0):\n        return 1\n    return solve(n-1)+solve(n-3)+solve(n-5)\n \n  # This code is contributed by ishankhandelwals.\n", "# Initialize to -1\ndp = []\n \n# This function returns the number of\n# arrangements to form 'n'\ndef solve(n):\n    # base case\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n \n# Checking if already calculated\n    if dp[n] != -1:\n        return dp[n]\n \n# Storing the result and returning\n    dp[n] = solve(n-1) + solve(n-3) + solve(n-5)\n    return dp[n]\n \n  # This code is contributed by ishankhandelwals.\n", "# Function to find nth fibonacci number\ndef fib(n):\n    if (n <= 1):\n        return n\n    x = fib(n - 1)\n    y = fib(n - 2)\n \n    return x + y\n \nn = 5;\n \n# Function Call\nprint(fib(n))\n \n#contributed by akashish__\n", "# Helper Function\ndef fibo_helper(n, ans):\n  # Base case\n  if (n <= 1):\n    return n\n \n  # To check if output already exists\n  if (ans[n] is not -1):\n    return ans[n]\n \n  # Calculate output\n  x = fibo_helper(n - 1, ans)\n  y = fibo_helper(n - 2, ans)\n \n  # Saving the output for future use\n  ans[n] = x + y\n \n  # Returning the final output\n  return ans[n]\n \n \ndef fibo(n):\n  ans = [-1]*(n+1)\n \n  # Initializing with -1\n  #for (i = 0; i <= n; i++) {\n  for i in range(0,n+1):\n    ans[i] = -1\n     \n  return fibo_helper(n, ans)\n \n \n# Code\nn = 5\n \n# Function Call\nprint(fibo(n))\n# contributed by akashish__\n", "# Python3 code for the above approach:\n \n# Function for calculating the nth\n# Fibonacci number\ndef fibo(n):\n  ans = [None] * (n + 1)\n \n  # Storing the independent values in the\n  # answer array\n  ans[0] = 0\n  ans[1] = 1\n \n  # Using the bottom-up approach\n  for i in range(2,n+1):\n    ans[i] = ans[i - 1] + ans[i - 2]\n \n  # Returning the final index\n  return ans[n]\n \n# Drivers code\nn = 5\n \n# Function Call\nprint(fibo(n))\n#contributed by akashish__\n", "# Python code for the above approach\n \n# Function for calculating the nth Fibonacci number\ndef fibo(n):\n    prevPrev, prev, curr = 0, 1, 1\n    # Using the bottom-up approach\n    for i in range(2, n+1):\n        curr = prev + prevPrev\n        prevPrev = prev\n        prev = curr\n    # Returning the final answer\n    return curr\n \n# Drivers code\nn = 5\n# Function Call\nprint(fibo(n))\n"], "Given A, B, C, find whether C is formed by the interleaving of A and B. Input Format:* The first argument of input contains a string, A. The second argument of input contains a string, B. The third argument of input contains a string, C. Output Format: Return an integer, 0 or 1: => 0 : False => 1 : True Constraints: 1 <= length(A), length(B), length(C) <= 150 Examples: Input 1: A = \"aabcc\" B = \"dbbca\" C = \"aadbbcbcac\" Output 1: 1 Explanation 1: \"aa\" (from A) + \"dbbc\" (from B) + \"bc\" (from A) + \"a\" (from B) + \"c\" (from A) Input 2: A = \"aabcc\" B = \"dbbca\" C = \"aadbbbaccc\" Output 2: 0 Explanation 2: It is not possible to get C by interleaving A and B.": "class Solution:\n    # @param A : string\n    # @param B : string\n    # @param C : string\n    # @return an integer\n    \n    def isInterleave(self, A, B, C):\n\n        if len(C)!=len(A)+len(B):\n            return 0\n\n        if len(A)==0:\n            return 1 if B==C else 0\n        if len(B)==0:\n            return 1 if A==C else 0\n        if C[-1]==A[-1] and C[-1]!=B[-1]:\n            return self.isInterleave(A[:-1],B,C[:-1])\n        elif C[-1]==B[-1] and C[-1]!=A[-1]:\n            return self.isInterleave(A,B[:-1],C[:-1])\n        elif C[-1]==B[-1] and C[-1]==A[-1]:\n            return 1 if (self.isInterleave(A[:-1],B,C[:-1]) + self.isInterleave(A,B[:-1],C[:-1])>0) else 0\n        else:\n            return 0\n\n\n\n", "Given a string A and a dictionary of words B, add spaces in A to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note : Make sure the strings are sorted in your result. Input Format: The first argument is a string, A. The second argument is an array of strings, B. Output Format: Return a vector of strings representing the answer as described in the problem statement. Constraints: 1 <= len(A) <= 50 1 <= len(B) <= 25 1 <= len(B[i]) <= 20 Examples: Input 1: A = \"b\" B = [\"aabbb\"] Output 1: [] Input 1: A = \"catsanddog\", B = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output 1: [\"cat sand dog\", \"cats and dog\"]": "class Solution:\n    # @param A : string\n    # @param B : list of strings\n    # @return an integer\n    def wordBreak(self, s, d):\n        wls = sorted(list(set(map(len, d))))\n        d = {k:1 for k in d}\n\n        arr = [0] * (len(s) + 1)\n        arr[0] = [\"\"]\n\n        i = 0\n        while i < len(s):\n            for j in wls:\n                if i + j > len(s):\n                    break\n                else:\n                    w = s[i:i + j]\n                    if w in d:\n                        if not arr[i + j]:\n                            arr[i + j] = [a + \" \" + w for a in arr[i]]\n                        else:\n                            arr[i + j] += [a + \" \" + w for a in arr[i]]\n\n            while True:\n                i += 1\n                if i == len(s) or arr[i]:\n                    break\n        if arr[-1]:\n            return sorted([s.strip() for s in arr[-1]])\n        else:\n            return []\n\n\n", "Given a string A containing just the characters \u2019(\u2018 and \u2019)\u2019. Find the length of the longest valid (well-formed) parentheses substring. Input Format: The only argument given is string A. Output Format: Return the length of the longest valid (well-formed) parentheses substring. Constraints: 1 <= length(A) <= 750000 For Example Input 1: A = \"(()\" Output 1: 2 Explanation 1: The longest valid parentheses substring is \"()\", which has length = 2. Input 2: A = \")()())\" Output 2: 4 Explanation 2: The longest valid parentheses substring is \"()()\", which has length = 4.": "class Solution:\n    # @param A : string\n    # @return an integer\n    def longestValidParentheses(self, A):\n        dpMap = dict()\n\n        def dp(i):\n            if i in dpMap:\n                return dpMap[i]\n\n            if i >= len(A) or A[i] == ')':\n                return i-1\n\n            ans = i-1\n            if i+1 < len(A):\n                if A[i+1] == ')':\n                    ans = i+1 + dp(i+2)-(i+2)+1\n                elif dp(i+1) != i:\n                    j = dp(i+1)+1\n                    if j < len(A) and A[j] == ')':\n                        ans = j + dp(j+1)-(j+1)+1\n\n            dpMap[i] = ans\n            return ans\n        \n        # print ([dp(i) for i in range(len(A))])\n        return max(dp(i)-i+1 for i in reversed(range(len(A))))\n\n\n\n", "Introduction to TensorFlow - GeeksforGeeks": [], "Top 50 R Interview Questions & Answers (2023)": [], "Top Python Interview Questions and Answers (2023)": ["try:\nraise ExceptionGroup('Example ExceptionGroup', (\nTypeError('Example TypeError'),\nValueError('Example ValueError'),\nKeyError('Example KeyError'),\nAttributeError('Example AttributeError')\n))\nexcept* TypeError:\n...\nexcept* ValueError as e:\n...\nexcept* (KeyError, AttributeError) as e:\n...\n", "match term:\n   case pattern-1:\n   action-1\n   case pattern-2:\n   action-2\n   case pattern-3:\n   action-3\n   case _:\n   action-default\n", "names = ['Jacob', 'Joe', 'Jim']\n \nif (name := input('Enter a name: ')) in names:\n    print(f'Hello, {name}!')\nelse:\n    print('Name not found.')\n"], "Data analysis using R - GeeksforGeeks": [], "Data Analysis with Python - GeeksforGeeks": ["import numpy as np\n  \nb = np.empty(2, dtype = int)\nprint('Matrix b : \\n', b)\n  \na = np.empty([2, 2], dtype = int)\nprint('\\nMatrix a : \\n', a)\n  \nc = np.empty([3, 3])\nprint('\\nMatrix c : \\n', c)\n", "import numpy as np\n  \nb = np.zeros(2, dtype = int)\nprint('Matrix b : \\n', b)\n  \na = np.zeros([2, 2], dtype = int)\nprint('\\nMatrix a : \\n', a)\n  \nc = np.zeros([3, 3])\nprint('\\nMatrix c : \\n', c)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing addition using arithmetic operator\nadd_ans = a+b\nprint(add_ans)\n \n# Performing addition using numpy function\nadd_ans = np.add(a, b)\nprint(add_ans)\n \n# The same functions and operations can be used for\n# multiple matrices\nc = np.array([1, 2, 3, 4])\nadd_ans = a+b+c\nprint(add_ans)\n \nadd_ans = np.add(a, b, c)\nprint(add_ans)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing subtraction using arithmetic operator\nsub_ans = a-b\nprint(sub_ans)\n \n# Performing subtraction using numpy function\nsub_ans = np.subtract(a, b)\nprint(sub_ans)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing multiplication using arithmetic\n# operator\nmul_ans = a*b\nprint(mul_ans)\n \n# Performing multiplication using numpy function\nmul_ans = np.multiply(a, b)\nprint(mul_ans)\n", "import numpy as np\n \n# Defining both the matrices\na = np.array([5, 72, 13, 100])\nb = np.array([2, 5, 10, 30])\n \n# Performing division using arithmetic operators\ndiv_ans = a/b\nprint(div_ans)\n \n# Performing division using numpy functions\ndiv_ans = np.divide(a, b)\nprint(div_ans)\n", "# Python program to demonstrate \n# the use of index arrays.\nimport numpy as np\n  \n# Create a sequence of integers from\n# 10 to 1 with a step of -2\na = np.arange(10, 1, -2) \nprint('\\n A sequential array with a negative step: \\n',a)\n  \n# Indexes are specified inside the np.array method.\nnewarr = a[np.array([3, 1, 2 ])]\nprint('\\n Elements at these indices are:\\n',newarr)\n", "# Python program for basic slicing.\nimport numpy as np\n \n# Arrange elements from 0 to 19\na = np.arrange(20)\nprint('\\n Array is:\\n ',a)\n \n# a[start:stop:step]\nprint('\\n a[-8:17:1] = ',a[-8:17:1])\n \n# The : operator means all elements till the end.\nprint('\\n a[10:] = ',a[10:])\n", "# Python program for indexing using basic slicing with ellipsis\nimport numpy as np\n \n# A 3 dimensional array.\nb = np.array([[[1, 2, 3],[4, 5, 6]],\n            [[7, 8, 9],[10, 11, 12]]])\n \nprint(b[...,1]) #Equivalent to b[: ,: ,1 ]\n", "import numpy as np\n \nmacros = np.array([\n[0.8, 2.9, 3.9],\n[52.4, 23.6, 36.5],\n[55.2, 31.7, 23.9],\n[14.4, 11, 4.9]\n])\n \n# Create a new array filled with zeros,\n# of the same shape as macros.\nresult = np.zeros_like(macros)\n \ncal_per_macro = np.array([3, 3, 8])\n \n# Now multiply each row of macros by\n# cal_per_macro. In Numpy, `*` is\n# element-wise multiplication between two arrays.\nfor i in range(macros.shape[0]):\n    result[i, :] = macros[i, :] * cal_per_macro\n \nresult\n", "import numpy as np\n \nv = np.array([12, 24, 36])\nw = np.array([45, 55])\n \n# To compute an outer product we first\n# reshape v to a column vector of shape 3x1\n# then broadcast it against w to yield an output\n# of shape 3x2 which is the outer product of v and w\nprint(np.reshape(v, (3, 1)) * w)\n \nX = np.array([[12, 22, 33], [45, 55, 66]])\n \n# x has shape 2x3 and v has shape (3, )\n# so they broadcast to 2x3,\nprint(X + v)\n \n# Add a vector to each column of a matrix X has\n# shape 2x3 and w has shape (2, ) If we transpose X\n# then it has shape 3x2 and can be broadcast against w\n# to yield a result of shape 3x2.\n \n# Transposing this yields the final result\n# of shape 2x3 which is the matrix.\nprint((X.T + w).T)\n \n# Another solution is to reshape w to be a column\n# vector of shape 2X1 we can then broadcast it\n# directly against X to produce the same output.\nprint(X + np.reshape(w, (2, 1)))\n \n# Multiply a matrix by a constant, X has shape 2x3.\n# Numpy treats scalars as arrays of shape();\n# these can be broadcast together to shape 2x3.\nprint(X * 2)\n", "import pandas as pd\nimport numpy as np\n \n \n# Creating empty series\nser = pd.Series()\n \nprint(ser)\n \n# simple array\ndata = np.array(['g', 'e', 'e', 'k', 's'])\n \nser = pd.Series(data)\nprint(ser)\n", "import pandas as pd\n \n# Calling DataFrame constructor\ndf = pd.DataFrame()\nprint(df)\n \n# list of strings\nlst = ['Geeks', 'For', 'Geeks', 'is',\n            'portal', 'for', 'Geeks']\n \n# Calling DataFrame constructor on list\ndf = pd.DataFrame(lst)\ndf\n", "import pandas as pd\n \n# Reading the CSV file\ndf = pd.read_csv('Iris.csv')\n \n# Printing top 5 rows\ndf.head()\n", "import pandas as pd\n \n# Reading the CSV file\ndf = pd.read_csv('Iris.csv')\n \n# applying filter function\ndf.filter(['Species', 'SepalLengthCm', 'SepalLengthCm']).head()\n", "# importing pandas module\nimport pandas as pd\n \n# Define a dictionary containing employee data\ndata1 = {'Name': ['Jai', 'Anuj', 'Jai', 'Princi',\n                  'Gaurav', 'Anuj', 'Princi', 'Abhi'],\n         'Age': [27, 24, 22, 32,\n                 33, 36, 27, 32],\n         'Address': ['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj',\n                     'Jaunpur', 'Kanpur', 'Allahabad', 'Aligarh'],\n         'Qualification': ['Msc', 'MA', 'MCA', 'Phd',\n                           'B.Tech', 'B.com', 'Msc', 'MA']}\n \n# Convert the dictionary into DataFrame\ndf = pd.DataFrame(data1)\n \nprint('Original Dataframe')\ndisplay(df)\n \n# applying groupby() function to\n# group the data on Name value.\ngk = df.groupby('Name')\n \n# Let's print the first entries\n# in all the groups formed.\nprint('After Creating Groups')\ngk.first()\n", "# importing pandas module\nimport pandas as pd\n \n# importing numpy as np\nimport numpy as np\n \n# Define a dictionary containing employee data\ndata1 = {'Name': ['Jai', 'Anuj', 'Jai', 'Princi',\n                  'Gaurav', 'Anuj', 'Princi', 'Abhi'],\n         'Age': [27, 24, 22, 32,\n                 33, 36, 27, 32],\n         'Address': ['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj',\n                     'Jaunpur', 'Kanpur', 'Allahabad', 'Aligarh'],\n         'Qualification': ['Msc', 'MA', 'MCA', 'Phd',\n                                  'B.Tech', 'B.com', 'Msc', 'MA']}\n \n \n# Convert the dictionary into DataFrame\ndf = pd.DataFrame(data1)\n \n# performing aggregation using\n# aggregate method\n \ngrp1 = df.groupby('Name')\n \ngrp1.aggregate(np.sum)\n", "# importing pandas module\nimport pandas as pd \n  \n# Define a dictionary containing employee data \ndata1 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Name':['Jai', 'Princi', 'Gaurav', 'Anuj'], \n        'Age':[27, 24, 22, 32],} \n    \n# Define a dictionary containing employee data \ndata2 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Address':['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj'], \n        'Qualification':['Btech', 'B.A', 'Bcom', 'B.hons']} \n  \n# Convert the dictionary into DataFrame  \ndf = pd.DataFrame(data1)\n  \n# Convert the dictionary into DataFrame  \ndf1 = pd.DataFrame(data2) \n   \n \ndisplay(df, df1) \n \n# combining series and dataframe\nres = pd.concat([df, df1], axis=1)\n  \nres\n", "# importing pandas module\nimport pandas as pd \n  \n# Define a dictionary containing employee data \ndata1 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Name':['Jai', 'Princi', 'Gaurav', 'Anuj'], \n        'Age':[27, 24, 22, 32],} \n    \n# Define a dictionary containing employee data \ndata2 = {'key': ['K0', 'K1', 'K2', 'K3'],\n         'Address':['Nagpur', 'Kanpur', 'Allahabad', 'Kannuaj'], \n        'Qualification':['Btech', 'B.A', 'Bcom', 'B.hons']} \n  \n# Convert the dictionary into DataFrame  \ndf = pd.DataFrame(data1)\n  \n# Convert the dictionary into DataFrame  \ndf1 = pd.DataFrame(data2) \n   \n \ndisplay(df, df1) \n \n# using .merge() function\nres = pd.merge(df, df1, on='key')\n  \nres\n", "# importing pandas module\nimport pandas as pd \n   \n# Define a dictionary containing employee data \ndata1 = {'Name':['Jai', 'Princi', 'Gaurav', 'Anuj'], \n        'Age':[27, 24, 22, 32]} \n     \n# Define a dictionary containing employee data \ndata2 = {'Address':['Allahabad', 'Kannuaj', 'Allahabad', 'Kannuaj'], \n        'Qualification':['MCA', 'Phd', 'Bcom', 'B.hons']} \n   \n# Convert the dictionary into DataFrame  \ndf = pd.DataFrame(data1,index=['K0', 'K1', 'K2', 'K3'])\n   \n# Convert the dictionary into DataFrame  \ndf1 = pd.DataFrame(data2, index=['K0', 'K2', 'K3', 'K4'])\n  \n \ndisplay(df, df1)  \n \n# joining dataframe\nres = df.join(df1)\n  \nres\n", "# Python program to show pyplot module\nimport matplotlib.pyplot as plt\n \n \nplt.plot([1, 2, 3, 4], [1, 4, 9, 16])\nplt.axis([0, 6, 0, 20])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \n# This will plot a simple bar chart\nplt.bar(df['Species'], df['SepalLengthCm'])\n \n# Title to the plot\nplt.title('Iris Dataset')\n \n# Adding the legends\nplt.legend(['bar'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.hist(df['SepalLengthCm'])\n \n# Title to the plot\nplt.title('Histogram')\n \n# Adding the legends\nplt.legend(['SepalLengthCm'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.scatter(df['Species'], df['SepalLengthCm'])\n \n# Title to the plot\nplt.title('Scatter Plot')\n \n# Adding the legends\nplt.legend(['SepalLengthCm'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.boxplot(df['SepalWidthCm'])\n \n# Title to the plot\nplt.title('Box Plot')\n \n# Adding the legends\nplt.legend(['SepalWidthCm'])\nplt.show()\n", "import matplotlib.pyplot as plt\nimport pandas as pd\n \ndf = pd.read_csv('Iris.csv')\n \nplt.imshow(df.corr() , cmap = 'autumn' , interpolation = 'nearest' )\n   \nplt.title('Heat Map')\nplt.show()\n", "df.shape\n", "df.info()\n", "df.describe()\n", "df.isnull().sum()\n", "data = df.drop_duplicates(subset ='Species',)\ndata\n", "df.value_counts('Species')\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.scatterplot(x='SepalLengthCm', y='SepalWidthCm',\n                hue='Species', data=df, )\n \n# Placing Legend outside the Figure\nplt.legend(bbox_to_anchor=(1, 1), loc=2)\n \nplt.show()\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.scatterplot(x='PetalLengthCm', y='PetalWidthCm',\n                hue='Species', data=df, )\n \n# Placing Legend outside the Figure\nplt.legend(bbox_to_anchor=(1, 1), loc=2)\n \nplt.show()\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.pairplot(df.drop(['Id'], axis = 1), \n             hue='Species', height=2)\n", "data.corr(method='pearson')\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n \nsns.heatmap(df.corr(method='pearson').drop(\n  ['Id'], axis=1).drop(['Id'], axis=0),\n            annot = True);\n \nplt.show()\n", "# importing packages\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n \n# Load the dataset\ndf = pd.read_csv('Iris.csv')\n \nsns.boxplot(x='SepalWidthCm', data=df)\n", "# Importing\nimport sklearn\nfrom sklearn.datasets import load_boston\nimport pandas as pd\nimport seaborn as sns\n \n# Load the dataset\ndf = pd.read_csv('Iris.csv')\n \n# IQR\nQ1 = np.percentile(df['SepalWidthCm'], 25,\n                interpolation = 'midpoint')\n \nQ3 = np.percentile(df['SepalWidthCm'], 75,\n                interpolation = 'midpoint')\nIQR = Q3 - Q1\n \nprint('Old Shape: ', df.shape)\n \n# Upper bound\nupper = np.where(df['SepalWidthCm'] >= (Q3+1.5*IQR))\n \n# Lower bound\nlower = np.where(df['SepalWidthCm'] <= (Q1-1.5*IQR))\n \n# Removing the Outliers\ndf.drop(upper[0], inplace = True)\ndf.drop(lower[0], inplace = True)\n \nprint('New Shape: ', df.shape)\n \nsns.boxplot(x='SepalWidthCm', data=df)\n"], "Data visualization with R and ggplot2 - GeeksforGeeks": [], "Getting Started with Plotly in R - GeeksforGeeks": [], "Data Visualization in R - GeeksforGeeks": [], "Python Seaborn Tutorial - GeeksforGeeks": ["# importing packages  \nimport seaborn as sns  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# setting the title using Matplotlib \nplt.title('Title using Matplotlib Function') \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# setting the x limit of the plot \nplt.xlim(5) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# changing the theme to dark \nsns.set_style('dark') \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# Removing the spines \nsns.despine() \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# changing the figure size \nplt.figure(figsize = (2, 4)) \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# Removing the spines \nsns.despine() \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n# draw lineplot  \nsns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \n# Setting the scale of the plot \nsns.set_context('paper') \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt  \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \n  \ndef plot(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data)  \n  \nwith sns.axes_style('darkgrid'): \n      \n    # Adding the subplot \n    plt.subplot(211) \n    plot() \n      \nplt.subplot(212) \nplot()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# current colot palette \npalette = sns.color_palette() \n  \n# plots the color palette as a \n# horizontal array \nsns.palplot(palette) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# current colot palette \npalette = sns.color_palette('PiYG', 11) \n  \n# diverging color palette \nsns.palplot(palette) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# current colot palette \npalette = sns.color_palette('Greens', 11) \n  \n# sequential color palette \nsns.palplot(palette) \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \ndef plot(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# setting the default color palette \nsns.set_palette('vlag') \nplt.subplot(211) \n  \n# plotting with the color palette \n# as vlag \nplot() \n  \n# setting another default color palette \nsns.set_palette('Accent') \nplt.subplot(212) \nplot() \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \ndef graph(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.8])  \n  \n# plotting the graph \ngraph() \n  \n# Creating second axes for the figure \nax2 = fig.add_axes([0.5, 0.5, 0.3, 0.3]) \n  \n# plotting the graph \ngraph() \n  \nplt.show()\n", "# importing packages  \nimport seaborn as sns  \nimport matplotlib.pyplot as plt \n  \n# loading dataset  \ndata = sns.load_dataset('iris')  \n  \ndef graph(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# Adding the subplot at the specified \n# grid position \nplt.subplot(121) \ngraph() \n  \n# Adding the subplot at the specified \n# grid position \nplt.subplot(122) \ngraph() \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \ndef graph(): \n    sns.lineplot(x='sepal_length', y='sepal_width', data=data) \n  \n# adding the subplots \naxes1 = plt.subplot2grid ( \n  (7, 1), (0, 0), rowspan = 2,  colspan = 1)  \ngraph() \n  \naxes2 = plt.subplot2grid ( \n  (7, 1), (2, 0), rowspan = 2, colspan = 1)  \ngraph() \n    \naxes3 = plt.subplot2grid ( \n  (7, 1), (4, 0), rowspan = 2, colspan = 1) \ngraph()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nplot = sns.FacetGrid(data, col='species') \nplot.map(plt.plot, 'sepal_width') \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('flights') \n  \nplot = sns.PairGrid(data) \nplot.map(plt.plot) \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \n# creating the relplot \nsns.relplot(x='sepal_width', y='species', data=data) \n  \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.scatterplot(x='sepal_length', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.lineplot(x='sepal_length', y='species', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.barplot(x='species', y='sepal_length', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.countplot(x='species', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.boxplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.violinplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.stripplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.swarmplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.factorplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.histplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.distplot(data['sepal_width']) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.jointplot(x='species', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.pairplot(data=data, hue='species') \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.rugplot(data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('iris') \n  \nsns.kdeplot(x='sepal_length', y='sepal_width', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \nsns.lmplot(x='total_bill', y='tip', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \nsns.regplot(x='total_bill', y='tip', data=data) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \n# correlation between the different parameters  \ntc = data.corr() \n  \nsns.heatmap(tc) \nplt.show()\n", "# importing packages \nimport seaborn as sns \nimport matplotlib.pyplot as plt \n  \n# loading dataset \ndata = sns.load_dataset('tips') \n  \n# correlation between the different parameters  \ntc = data.corr() \n  \nsns.clustermap(tc) \nplt.show()\n"], "Python Plotly tutorial - GeeksforGeeks": ["import plotly.express as px  \n  \n  \n# Creating the Figure instance \nfig = px.line(x=[1,2, 3], y=[1, 2, 3])  \n  \n# printing the figure instance \nprint(fig)\n", "import plotly.express as px  \n  \n  \n# Creating the Figure instance \nfig = px.line(x=[1, 2, 3], y=[1, 2, 3])  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the line chart \nfig = px.line(df, x='species', y='petal_width')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the bar chart \nfig = px.bar(df, x='sepal_width', y='sepal_length')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the histogram \nfig = px.histogram(df, x='sepal_length', y='petal_width')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the scatter chart \nfig = px.scatter(df, x='species', y='petal_width')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# plotting the bubble chart \nfig = px.scatter(df, x='species', y='petal_width',  \n                 size='petal_length', color='species')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the tips dataset \ndf = px.data.tips()  \n  \n# plotting the pie chart \nfig = px.pie(df, values='total_bill', names='day')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the tips dataset \ndf = px.data.tips()  \n  \n# plotting the box chart \nfig = px.box(df, x='day', y='total_bill')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# using the tips dataset \ndf = px.data.tips()  \n  \n# plotting the violin chart \nfig = px.violin(df, x='day', y='total_bill') \n  \n# showing the plot \nfig.show()\n", "import plotly.figure_factory as ff  \n  \n# Data to be plotted \ndf = [dict(Task='A', Start='2020-01-01', Finish='2009-02-02'),  \n    dict(Task='Job B', Start='2020-03-01', Finish='2020-11-11'),  \n    dict(Task='Job C', Start='2020-08-06', Finish='2020-09-21')]  \n  \n# Creating the plot \nfig = ff.create_gantt(df)  \nfig.show()\n", "import plotly.graph_objects as go  \n  \n  \n# Creating the X, Y value that will \n# change the values of Z as a function \nfeature_x = np.arange(0, 50, 2)  \nfeature_y = np.arange(0, 50, 3)  \n  \n# Creating 2-D grid of features  \n[X, Y] = np.meshgrid(feature_x, feature_y)  \n  \nZ = np.cos(X / 2) + np.sin(Y / 4)  \n  \n# plotting the figure \nfig = go.Figure(data =\n    go.Contour(x = feature_x, y = feature_y, z = Z))  \n  \nfig.show()\n", "import plotly.graph_objects as go  \n  \n  \nfeature_x = np.arange(0, 50, 2)  \nfeature_y = np.arange(0, 50, 3)  \n  \n# Creating 2-D grid of features  \n[X, Y] = np.meshgrid(feature_x, feature_y)  \n  \nZ = np.cos(X / 2) + np.sin(Y / 4)  \n  \n# plotting the figure \nfig = go.Figure(data =\n     go.Heatmap(x = feature_x, y = feature_y, z = Z,))  \n  \nfig.show()\n", "import plotly.express as px  \n  \n# using the iris dataset \ndf = px.data.iris()  \n  \n# Calculating the error field \ndf['error'] = df['petal_length']/100\n  \n# plotting the scatter chart \nfig = px.scatter(df, x='species', y='petal_width', \n                error_x='error', error_y='error')  \n  \n# showing the plot \nfig.show()\n", "import plotly.express as px  \n  \n# data to be plotted \ndf = px.data.tips()  \n  \n# plotting the figure \nfig = px.line_3d(df, x='sex', y='day',  \n                 z='time', color='sex')  \n  \nfig.show() \n", "import plotly.express as px  \n  \n# Data to be plotted \ndf = px.data.iris()  \n  \n# Plotting the figure \nfig = px.scatter_3d(df, x = 'sepal_width',  \n                    y = 'sepal_length',  \n                    z = 'petal_width',  \n                    color = 'species')  \n  \nfig.show() \n", "import plotly.graph_objects as go  \nimport numpy as np  \n  \n# Data to be plotted \nx = np.outer(np.linspace(-2, 2, 30), np.ones(30))  \ny = x.copy().T  \nz = np.cos(x ** 2 + y ** 2)  \n  \n# plotting the figure \nfig = go.Figure(data=[go.Surface(x=x, y=y, z=z)])  \n  \nfig.show()\n", "import plotly.graph_objects as px \nimport numpy as np \n  \n  \n# creating random data through randomint \n# function of numpy.random \nnp.random.seed(42) \n  \n# Data to be Plotted \nrandom_x = np.random.randint(1, 101, 100) \nrandom_y = np.random.randint(1, 101, 100) \n  \nplot = px.Figure(data=[px.Scatter( \n    x=random_x, \n    y=random_y, \n    mode='markers',) \n]) \n  \n# Add dropdown \nplot.update_layout( \n    updatemenus=[ \n        dict( \n            buttons=list([ \n                dict( \n                    args=['type', 'scatter'], \n                    label='Scatter Plot', \n                    method='restyle'\n                ), \n                dict( \n                    args=['type', 'bar'], \n                    label='Bar Chart', \n                    method='restyle'\n                ) \n            ]), \n            direction='down', \n        ), \n    ] \n) \n  \nplot.show() \n", "import plotly.graph_objects as px \nimport pandas as pd \n  \n# reading the database \ndata = pd.read_csv('tips.csv') \n  \n  \nplot = px.Figure(data=[px.Scatter( \n    x=data['day'], \n    y=data['tip'], \n    mode='markers',) \n]) \n  \n# Add dropdown \nplot.update_layout( \n    updatemenus=[ \n        dict( \n            type='buttons', \n            direction='left', \n            buttons=list([ \n                dict( \n                    args=['type', 'scatter'], \n                    label='Scatter Plot', \n                    method='restyle'\n                ), \n                dict( \n                    args=['type', 'bar'], \n                    label='Bar Chart', \n                    method='restyle'\n                ) \n            ]), \n        ), \n    ] \n) \n  \nplot.show() \n", "import plotly.graph_objects as px  \nimport plotly.express as go  \nimport numpy as np  \n  \ndf = go.data.tips()  \n  \nx = df['total_bill']  \ny = df['day']  \n  \nplot = px.Figure(data=[px.Scatter(  \n    x=x,  \n    y=y,  \n    mode='lines',)  \n])  \n  \nplot.update_layout(  \n    xaxis=dict(  \n        rangeselector=dict(  \n            buttons=list([  \n                dict(count=1,  \n                    step='day',  \n                    stepmode='backward'),  \n            ])  \n        ),  \n        rangeslider=dict(  \n            visible=True\n        ),  \n    )  \n)  \n  \nplot.show()  \n"], "Python Bokeh tutorial - Interactive Data Visualization with Bokeh - GeeksforGeeks": ["# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Line Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [5, 4, 3, 2, 1]  \n  \n# plotting the line graph  \ngraph.line(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules \nfrom bokeh.plotting import figure, output_file, show \n  \n# instantiating the figure object \ngraph = figure(title='Bokeh Line Graph') \n  \n# the points to be plotted \nx = [1, 2, 3, 4, 5] \ny = [5, 4, 3, 2, 1] \n  \n# plotting the 1st line graph \ngraph.line(x, x, legend_label='Line 1') \n  \n# plotting the 2nd line graph with a \n# different color \ngraph.line(y, x, legend_label='Line 2', \n           line_color='green') \n  \n# displaying the model \nshow(graph) \n", "# importing the modules \nfrom bokeh.plotting import figure, output_file, show \n  \n# instantiating the figure object \ngraph = figure(title='Bokeh Line Graph') \n  \n# the points to be plotted \nx = [1, 2, 3, 4, 5] \ny = [5, 4, 3, 2, 1] \n  \n# plotting the 1st line graph \ngraph.line(x, x, legend_label='Line 1') \n  \n# plotting the 2nd line graph with a \n# different color \ngraph.line(y, x, legend_label='Line 2', \n           line_color='green') \n  \ngraph.legend.title = 'Title of the legend'\ngraph.legend.location ='top_left'\ngraph.legend.label_text_font_size = '17pt'\n  \n# displaying the model \nshow(graph) \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Line Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [5, 4, 3, 2, 1]  \n  \n# plotting the line graph  \ngraph.line(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Bar Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [1, 2, 3, 4, 5]   \n  \n# height / thickness of the plot \nheight = 0.5\n  \n# plotting the bar graph  \ngraph.hbar(x, right = y, height = height)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Bar Graph')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [1, 2, 3, 4, 5]   \n  \n# height / thickness of the plot \nwidth = 0.5\n  \n# plotting the bar graph  \ngraph.vbar(x, top = y, width = width)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \nfrom bokeh.palettes import magma  \nimport random  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Scatter Graph')  \n  \n# points to be plotted  \nx = [n for n in range(256)]  \ny = [random.random() + 1 for n in range(256)]  \n  \n  \n# plotting the graph  \ngraph.scatter(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \nfrom bokeh.palettes import magma  \nimport random  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Patch Plo')  \n  \n# points to be plotted  \nx = [n for n in range(256)]  \ny = [random.random() + 1 for n in range(256)]  \n  \n# plotting the graph  \ngraph.patch(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# Implementation of bokeh function  \n      \nimport numpy as np  \nfrom bokeh.plotting import figure, output_file, show  \n      \ny = [1, 2, 3, 4, 5]  \nx1 = [2, 4, 5, 2, 4]  \nx2 = [1, 2, 2, 3, 6]  \n  \np = figure(plot_width=300, plot_height=300)  \n  \n# area plot  \np.harea(x1=x1, x2=x2, y=y,fill_color='green')  \n  \nshow(p)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Wedge Graph')  \n      \n# the points to be plotted  \nx = 0\ny = 0\n  \n# radius of the wedge  \nradius = 15\n  \n# start angle of the wedge  \nstart_angle = 1\n  \n# end angle of the wedge  \nend_angle = 2\n  \n# plotting the graph  \ngraph.wedge(x, y, radius = radius,  \n            start_angle = start_angle,  \n            end_angle = end_angle)  \n      \n# displaying the model  \nshow(graph)  \n", "import numpy as np  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# creating the figure object \nplot = figure(plot_width = 300, plot_height = 300)  \n  \nplot.circle(x = [1, 2, 3], y = [3, 7, 5], size = 20)  \n  \nshow(plot)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Oval Graph')  \n      \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [i * 2 for i in x]  \n  \n# plotting the graph  \ngraph.oval(x, y,  \n        height = 0.5,  \n        width = 1)  \n      \n# displaying the model  \nshow(graph)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Triangle Graph')  \n      \n# the points to be plotted  \nx = 1\ny = 1\n  \n# plotting the graph  \ngraph.triangle(x, y, size = 150)  \n      \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Rectangle Graph', match_aspect = True)  \n  \n# the points to be plotted  \nx = 0\ny = 0\nwidth = 10\nheight = 5\n  \n# plotting the graph  \ngraph.rect(x, y, width, height)  \n      \n# displaying the model  \nshow(graph)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n      \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Multiple Polygons Graph')  \n      \n# the points to be plotted  \nxs = [[[[1, 1, 3, 4]]]]  \nys = [[[[1, 3, 2 ,1]]]]  \n      \n# plotting the graph  \ngraph.multi_polygons(xs, ys)  \n      \n# displaying the model  \nshow(graph)  \n", "from bokeh.io import output_file, show \nfrom bokeh.layouts import column \nfrom bokeh.plotting import figure \n  \n  \nx = [1, 2, 3, 4, 5, 6] \ny0 = x \ny1 = [i * 2 for i in x] \ny2 = [i ** 2 for i in x] \n  \n# create a new plot \ns1 = figure(width=200, plot_height=200) \ns1.circle(x, y0, size=10, alpha=0.5) \n  \n# create another one \ns2 = figure(width=200, height=200) \ns2.triangle(x, y1, size=10, alpha=0.5) \n  \n# create and another \ns3 = figure(width=200, height=200) \ns3.square(x, y2, size=10, alpha=0.5) \n  \n# put all the plots in a VBox \np = column(s1, s2, s3) \n  \n# show the results \nshow(p)\n", "from bokeh.io import output_file, show \nfrom bokeh.layouts import row \nfrom bokeh.plotting import figure \n  \n  \nx = [1, 2, 3, 4, 5, 6] \ny0 = x \ny1 = [i * 2 for i in x] \ny2 = [i ** 2 for i in x] \n  \n# create a new plot \ns1 = figure(width=200, plot_height=200) \ns1.circle(x, y0, size=10, alpha=0.5) \n  \n# create another one \ns2 = figure(width=200, height=200) \ns2.triangle(x, y1, size=10, alpha=0.5) \n  \n# create and another \ns3 = figure(width=200, height=200) \ns3.square(x, y2, size=10, alpha=0.5) \n  \n# put all the plots in a VBox \np = row(s1, s2, s3) \n  \n# show the results \nshow(p)\n", "from bokeh.io import output_file, show \nfrom bokeh.layouts import gridplot \nfrom bokeh.plotting import figure \n  \n  \nx = [1, 2, 3, 4, 5, 6] \ny0 = x \ny1 = [i * 2 for i in x] \ny2 = [i ** 2 for i in x] \n  \n# create a new plot \ns1 = figure() \ns1.circle(x, y0, size=10, alpha=0.5) \n  \n# create another one \ns2 = figure() \ns2.triangle(x, y1, size=10, alpha=0.5) \n  \n# create and another \ns3 = figure() \ns3.square(x, y2, size=10, alpha=0.5) \n  \n# put all the plots in a grid \np = gridplot([[s1, None], [s2, s3]], plot_width=200, plot_height=200) \n  \n# show the results \nshow(p)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh ToolBar', toolbar_location='below')  \n  \n# the points to be plotted  \nx = [1, 2, 3, 4, 5]  \ny = [1, 2, 3, 4, 5]   \n  \n# height / thickness of the plot \nwidth = 0.5\n  \n# plotting the scatter graph  \ngraph.scatter(x, y)  \n  \n# displaying the model  \nshow(graph)\n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# file to save the model  \noutput_file('gfg.html')  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Hiding Glyphs')  \n  \n# plotting the graph  \ngraph.vbar(x = 1, top = 5,  \n        width = 1, color = 'violet',  \n        legend_label = 'Violet Bar')  \ngraph.vbar(x = 2, top = 5,  \n        width = 1, color = 'green',  \n        legend_label = 'Green Bar')  \ngraph.vbar(x = 3, top = 5,  \n        width = 1, color = 'yellow',  \n        legend_label = 'Yellow Bar')  \ngraph.vbar(x = 4, top = 5,  \n        width = 1, color = 'red',  \n        legend_label = 'Red Bar')  \n  \n# enable hiding of the glyphs  \ngraph.legend.click_policy = 'hide'\n  \n# displaying the model  \nshow(graph)  \n", "# importing the modules  \nfrom bokeh.plotting import figure, output_file, show  \n  \n# file to save the model  \noutput_file('gfg.html')  \n          \n# instantiating the figure object  \ngraph = figure(title = 'Bokeh Hiding Glyphs')  \n  \n# plotting the graph  \ngraph.vbar(x = 1, top = 5,  \n        width = 1, color = 'violet',  \n        legend_label = 'Violet Bar',  \n        muted_alpha=0.2)  \ngraph.vbar(x = 2, top = 5,  \n        width = 1, color = 'green',  \n        legend_label = 'Green Bar',  \n        muted_alpha=0.2)  \ngraph.vbar(x = 3, top = 5,  \n        width = 1, color = 'yellow',  \n        legend_label = 'Yellow Bar',  \n        muted_alpha=0.2)  \ngraph.vbar(x = 4, top = 5,  \n        width = 1, color = 'red',  \n        legend_label = 'Red Bar',  \n        muted_alpha=0.2)  \n  \n# enable hiding of the glyphs  \ngraph.legend.click_policy = 'mute'\n  \n# displaying the model  \nshow(graph)  \n", "from bokeh.io import show \nfrom bokeh.models import Button, CustomJS \n  \nbutton = Button(label='GFG') \nbutton.js_on_click(CustomJS( \n  code='console.log('button: click!', this.toString())')) \n  \nshow(button)\n", "from bokeh.io import show \nfrom bokeh.models import CheckboxGroup, CustomJS \n  \nL = ['First', 'Second', 'Third'] \n  \n# the active parameter sets checks the selected value  \n# by default \ncheckbox_group = CheckboxGroup(labels=L, active=[0, 2]) \n  \ncheckbox_group.js_on_click(CustomJS(code=''' \n    console.log('checkbox_group: active=' + this.active, this.toString()) \n''')) \n  \nshow(checkbox_group)\n", "from bokeh.io import show \nfrom bokeh.models import RadioGroup, CustomJS \n  \nL = ['First', 'Second', 'Third'] \n  \n# the active parameter sets checks the selected value  \n# by default \nradio_group = RadioGroup(labels=L, active=1) \n  \nradio_group.js_on_click(CustomJS(code=''' \n    console.log('radio_group: active=' + this.active, this.toString()) \n''')) \n  \nshow(radio_group) \n", "from bokeh.io import show \nfrom bokeh.models import CustomJS, Slider \n  \nslider = Slider(start=1, end=20, value=1, step=2, title='Slider') \n  \nslider.js_on_change('value', CustomJS(code=''' \n    console.log('slider: value=' + this.value, this.toString()) \n''')) \n  \nshow(slider)\n", "from bokeh.io import show \nfrom bokeh.models import CustomJS, Dropdown \n  \nmenu = [('First', 'First'), ('Second', 'Second'), ('Third', 'Third')] \n  \ndropdown = Dropdown(label='Dropdown Menu', button_type='success', menu=menu) \n  \ndropdown.js_on_event('menu_item_click', CustomJS( \n    code='console.log('dropdown: ' + this.item, this.toString())')) \n  \nshow(dropdown)\n", "from bokeh.plotting import figure, output_file, show \nfrom bokeh.models import Panel, Tabs \nimport numpy as np \nimport math \n  \n  \nfig1 = figure(plot_width=300, plot_height=300) \n  \nx = [1, 2, 3, 4, 5] \ny = [5, 4, 3, 2, 1] \n  \nfig1.line(x, y, line_color='green') \ntab1 = Panel(child=fig1, title='Tab 1') \n  \nfig2 = figure(plot_width=300, plot_height=300) \n  \nfig2.line(y, x, line_color='red') \ntab2 = Panel(child=fig2, title='Tab 2') \n  \nall_tabs = Tabs(tabs=[tab1, tab2]) \n  \nshow(all_tabs)\n"], "Matplotlib Tutorial - GeeksforGeeks": ["import matplotlib.pyplot as plt \n  \n# initializing the data \nx = [10, 20, 30, 40] \ny = [20, 30, 40, 50] \n  \n# plotting the data \nplt.plot(x, y) \n  \n# Adding the title \nplt.title('Simple Plot') \n  \n# Adding the labels \nplt.ylabel('y-axis') \nplt.xlabel('x-axis') \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nplt.plot([1, 2, 3, 4], [1, 4, 9, 16])  \nplt.axis([0, 6, 0, 20])  \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating a new axes for the figure \nax = fig.add_axes([1, 1, 1, 1])  \n  \n# Adding the data to be plotted \nax.plot([2, 3, 4, 5, 5, 6, 6], \n        [5, 7, 1, 3, 4, 6 ,8]) \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax1 = fig.add_axes([1, 1, 1, 1])  \n  \n# Creating second axes for the figure \nax2 = fig.add_axes([1, 0.5, 0.5, 0.5]) \n  \n# Adding the data to be plotted \nax1.plot([2, 3, 4, 5, 5, 6, 6],  \n         [5, 7, 1, 3, 4, 6 ,8]) \nax2.plot([1, 2, 3, 4, 5],  \n         [2, 3, 4, 5, 6]) \n  \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n# Creating the axes object with argument as  \n# [left, bottom, width, height] \nax = plt.axes([1, 1, 1, 1])\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \nfig = plt.figure(figsize = (5, 4)) \n  \n# Adding the axes to the figure \nax = fig.add_axes([1, 1, 1, 1]) \n  \n# plotting 1st dataset to the figure \nax1 = ax.plot([1, 2, 3, 4], [1, 2, 3, 4]) \n  \n# plotting 2nd dataset to the figure \nax2 = ax.plot([1, 2, 3, 4], [2, 3, 4, 5]) \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax = fig.add_axes([0.1, 0.1, 0.8, 0.8])  \n  \n# Adding the data to be plotted \nax.plot(x, y) \nax.set_xlim(1, 2) \nax.set_xticklabels(( \n  'one', 'two', 'three', 'four', 'five', 'six'))  \nplt.show()\n", "# Python program to show pyplot module \nimport matplotlib.pyplot as plt  \nfrom matplotlib.figure import Figure  \n  \n# Creating a new figure with width = 5 inches \n# and height = 4 inches \nfig = plt.figure(figsize =(5, 4))  \n  \n# Creating first axes for the figure \nax1 = fig.add_axes([0.1, 0.1, 0.8, 0.8])  \n  \n# Creating second axes for the figure \nax2 = fig.add_axes([0.5, 0.5, 0.3, 0.3]) \n  \n# Adding the data to be plotted \nax1.plot([5, 4, 3, 2, 1], [2, 3, 4, 5, 6]) \nax2.plot([1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \nz = [1, 3, 1]  \n  \n# Creating figure object  \nplt.figure()  \n  \n# adding first subplot  \nplt.subplot(121)  \nplt.plot(x, y)  \n  \n# adding second subplot  \nplt.subplot(122)  \nplt.plot(z, y)\n", "import matplotlib.pyplot as plt  \n  \n# Creating the figure and subplots \n# according the argument passed \nfig, axes = plt.subplots(1, 2) \n  \n# plotting the data in the 1st subplot \naxes[0].plot([1, 2, 3, 4], [1, 2, 3, 4]) \n  \n# plotting the data in the 1st subplot only \naxes[0].plot([1, 2, 3, 4], [4, 3, 2, 1]) \n  \n# plotting the data in the 2nd subplot only \naxes[1].plot([1, 2, 3, 4], [1, 1, 1, 1])\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \nz = [1, 3, 1]  \n  \n# adding the subplots \naxes1 = plt.subplot2grid ( \n  (7, 1), (0, 0), rowspan = 2,  colspan = 1)  \naxes2 = plt.subplot2grid ( \n  (7, 1), (2, 0), rowspan = 2, colspan = 1)  \naxes3 = plt.subplot2grid ( \n  (7, 1), (4, 0), rowspan = 2, colspan = 1)  \n  \n# plotting the data \naxes1.plot(x, y) \naxes2.plot(x, z) \naxes3.plot(z, y)\n", "import matplotlib.pyplot as plt  \n  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \nplt.plot(x, y) \nplt.plot(y, x) \n  \n# Adding the legends \nplt.legend(['blue', 'orange']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3]  \ny = [3, 2, 1]  \n  \n# This will plot a simple line chart \n# with elements of x as x axis and y \n# as y axis \nplt.plot(x, y) \nplt.title('Line Chart') \n  \n# Adding the legends \nplt.legend(['Line']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3, 12, 2, 4, 4]  \ny = [3, 2, 1, 4, 5, 6, 7]  \n  \n# This will plot a simple bar chart \nplt.bar(x, y) \n  \n# Title to the plot \nplt.title('Bar Chart') \n  \n# Adding the legends \nplt.legend(['bar']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [1, 2, 3, 4, 5, 6, 7, 4]  \n# This will plot a simple histogram \nplt.hist(x, bins = [1, 2, 3, 4, 5, 6, 7]) \n# Title to the plot \nplt.title('Histogram') \n# Adding the legends \nplt.legend(['bar']) \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [3, 1, 3, 12, 2, 4, 4] \ny = [3, 2, 1, 4, 5, 6, 7] \n  \n# This will plot a simple scatter chart \nplt.scatter(x, y) \n  \n# Adding legend to the plot \nplt.legend('A') \n  \n# Title to the plot \nplt.title('Scatter chart') \nplt.show()\n", "import matplotlib.pyplot as plt  \n# data to display on plots  \nx = [1, 2, 3, 4]  \n  \n# this will explode the 1st wedge \n# i.e. will separate the 1st wedge \n# from the chart \ne  =(0.1, 0, 0, 0) \n  \n# This will plot a simple pie chart \nplt.pie(x, explode = e) \n  \n# Title to the plot \nplt.title('Pie chart') \nplt.show()\n", "import matplotlib.pyplot as plt  \n# Creating the figure object \nfig = plt.figure() \n  \n# keeping the projection = 3d \n# creates the 3d plot \nax = plt.axes(projection = '3d')\n", "import matplotlib.pyplot as plt  \nx = [1, 2, 3, 4, 5] \ny = [1, 4, 9, 16, 25] \nz = [1, 8, 27, 64, 125] \n# Creating the figure object \nfig = plt.figure() \n# keeping the projection = 3d \n# creates the 3d plot \nax = plt.axes(projection = '3d') \nax.plot3D(z, y, x)\n", "# importing required libraries  \nimport matplotlib.pyplot as plt  \nimport matplotlib.image as img  \n# reading the image  \ntestImage = img.imread('g4g.png')  \n# displaying the image  \nplt.imshow(testImage)  \n"], "You are climbing a stair case and it takes A steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Input Format: The first and the only argument contains an integer A, the number of steps. Output Format: Return an integer, representing the number of ways to reach the top. Constrains: 1 <= A <= 36 Example : Input 1: A = 2 Output 1: 2 Explanation 1: [1, 1], [2] Input 2: A = 3 Output 2: 3 Explanation 2: [1 1 1], [1 2], [2 1]": "class Solution:\n    # @param A : integer\n    # @return an integer\n    def climbStairs(self, A):\n        res = [1, 1]\n        for i in range(2, A+1):\n            res.append(res[i-1] + res[i-2])\n        return res[A]\n        \n\n\n", "Command Pattern - GeeksforGeeks": [], "Adapter Pattern - GeeksforGeeks": [], "Singleton Design Pattern | Implementation - GeeksforGeeks": [], "Observer Pattern | Set 1 (Introduction) - GeeksforGeeks": [], "Understanding PyTorch Lightning DataModules - GeeksforGeeks": ["# import module \nimport torch  \n  \n# To get the layers and losses for our model \nfrom torch import nn  \nimport pytorch_lightning as pl  \n  \n# To get the activation function for our model \nimport torch.nn.functional as F  \n  \n# To get MNIST data and transforms \nfrom torchvision import datasets, transforms \n  \n# To get the optimizer for our model \nfrom torch.optim import SGD  \n  \n# To get random_split to split training \n# data into training and validation data \n# and DataLoader to create dataloaders for train,  \n# valid and test data to be returned \n# by our data module \nfrom torch.utils.data import random_split, DataLoader  \n  \nclass model(pl.LightningModule):  \n    def __init__(self):  \n        super(model, self).__init__()  \n          \n        # Defining our model architecture \n        self.fc1 = nn.Linear(28*28, 256)  \n        self.fc2 = nn.Linear(256, 128)  \n        self.out = nn.Linear(128, 10)  \n          \n        # Defining learning rate \n        self.lr = 0.01\n          \n        # Defining loss  \n        self.loss = nn.CrossEntropyLoss()  \n    \n    def forward(self, x): \n        \n          # Defining the forward pass of the model \n        batch_size, _, _, _ = x.size()  \n        x = x.view(batch_size, -1)  \n        x = F.relu(self.fc1(x))  \n        x = F.relu(self.fc2(x))  \n        return self.out(x)  \n    \n    def configure_optimizers(self): \n        \n          # Defining and returning the optimizer for our model \n        # with the defines parameters \n        return torch.optim.SGD(self.parameters(), lr = self.lr)  \n    \n    def training_step(self, train_batch, batch_idx):  \n        \n          # Defining training steps for our model \n        x, y = train_batch  \n        logits = self.forward(x)  \n        loss = self.loss(logits, y)  \n        return loss  \n    \n    def validation_step(self, valid_batch, batch_idx):  \n        \n        # Defining validation steps for our model \n        x, y = valid_batch  \n        logits = self.forward(x)  \n        loss = self.loss(logits, y) \n  \nclass DataModuleMNIST(pl.LightningDataModule): \n    def __init__(self): \n        super().__init__() \n          \n        # Directory to store MNIST Data \n        self.download_dir = '' \n          \n        # Defining batch size of our data \n        self.batch_size = 32\n          \n        # Defining transforms to be applied on the data \n        self.transform = transforms.Compose([ \n            transforms.ToTensor() \n        ]) \n  \n    def prepare_data(self): \n        \n          # Downloading our data \n        datasets.MNIST(self.download_dir,  \n                       train = True, download = True) \n          \n        datasets.MNIST(self.download_dir, \n                       train = False, download = True) \n  \n    def setup(self, stage=None): \n        \n          # Loading our data after applying the transforms \n        data = datasets.MNIST(self.download_dir, \n                              train = True,  \n                              transform = self.transform) \n          \n        self.train_data, self.valid_data = random_split(data, \n                                                        [55000, 5000]) \n  \n        self.test_data = datasets.MNIST(self.download_dir, \n                                        train = False, \n                                        transform = self.transform) \n  \n    def train_dataloader(self): \n        \n          # Generating train_dataloader \n        return DataLoader(self.train_data,  \n                          batch_size = self.batch_size) \n  \n    def val_dataloader(self): \n        \n          # Generating val_dataloader \n        return DataLoader(self.valid_data, \n                          batch_size = self.batch_size) \n  \n    def test_dataloader(self): \n        \n        # Generating test_dataloader \n        return DataLoader(self.test_data, \n                          batch_size = self.batch_size) \n  \nclf = model()  \nmnist = DataModuleMNIST()  \ntrainer = pl.Trainer() \ntrainer.fit(clf, mnist)  \n"], "Getting Started with PyTorch - GeeksforGeeks": ["# importing torch\nimport torch\n \n# creating a tensors\nt1=torch.tensor([1, 2, 3, 4])\nt2=torch.tensor([[1, 2, 3, 4],\n                 [5, 6, 7, 8],\n                 [9, 10, 11, 12]])\n \n# printing the tensors:\nprint('Tensor t1: \\n', t1)\nprint('\\nTensor t2: \\n', t2)\n \n# rank of tensors\nprint('\\nRank of t1: ', len(t1.shape))\nprint('Rank of t2: ', len(t2.shape))\n \n# shape of tensors\nprint('\\nRank of t1: ', t1.shape)\nprint('Rank of t2: ', t2.shape)\n", "# importing torch module\nimport torch\nimport numpy as np\n \n# list of values to be stored as tensor\ndata1 = [1, 2, 3, 4, 5, 6]\ndata2 = np.array([1.5, 3.4, 6.8,\n                9.3, 7.0, 2.8])\n \n# creating tensors and printing \nt1 = torch.tensor(data1)\nt2 = torch.Tensor(data1)\nt3 = torch.as_tensor(data2)\nt4 = torch.from_numpy(data2)\n \nprint('Tensor: ',t1, 'Data type: ', t1.dtype,'\\n')\nprint('Tensor: ',t2, 'Data type: ', t2.dtype,'\\n')\nprint('Tensor: ',t3, 'Data type: ', t3.dtype,'\\n')\nprint('Tensor: ',t4, 'Data type: ', t4.dtype,'\\n')\n", "# import torch module\nimport torch \n \n# defining tensor\nt = torch.tensor([[1, 2, 3, 4],\n                 [5, 6, 7, 8],\n                 [9, 10, 11, 12]])\n \n# reshaping the tensor\nprint('Reshaping')\nprint(t.reshape(6, 2))\n \n# resizing the tensor\nprint('\\nResizing')\nprint(t.resize(2, 6))\n \n# transposing the tensor\nprint('\\nTransposing')\nprint(t.transpose(1, 0))\n", "# import torch module\nimport torch \n \n# defining two tensors\nt1 = torch.tensor([1, 2, 3, 4])\nt2 = torch.tensor([5, 6, 7, 8])\n \n# adding two tensors\nprint('tensor2 + tensor1')\nprint(torch.add(t2, t1))\n \n# subtracting two tensor\nprint('\\ntensor2 - tensor1')\nprint(torch.sub(t2, t1))\n \n# multiplying two tensors\nprint('\\ntensor2 * tensor1')\nprint(torch.mul(t2, t1))\n \n# diving two tensors\nprint('\\ntensor2 / tensor1')\nprint(torch.div(t2, t1))\n", "# importing torch\nimport torch\n \n# creating a tensor\nt1=torch.tensor(1.0, requires_grad = True)\nt2=torch.tensor(2.0, requires_grad = True)\n \n# creating a variable and gradient\nz=100 * t1 * t2\nz.backward()\n \n# printing gradient\nprint('dz/dt1 : ', t1.grad.data)\nprint('dz/dt2 : ', t2.grad.data)\n", "class Model (nn.Module) : \n \n         def __init__(self): \n \n              super(Model, self).__init__()\n \n              self.linear = torch.nn.Linear(1, 1)  \n \n      def forward(self, x):\n \n              y_pred = self.linear(x)\n \n             return y_pred\n", "# importing torch\nimport torch\n \n# training input(X) and output(y)\nX = torch.Tensor([[1], [2], [3],\n                [4], [5], [6]])\ny = torch.Tensor([[5], [10], [15],\n                  [20], [25], [30]])\n \nclass Model(torch.nn.Module):\n \n    # defining layer\n    def __init__(self):\n        super(Model, self).__init__()\n        self.linear = torch.nn.Linear(1, 1) \n     \n    # implementing forward pass\n    def forward(self, x):\n        y_pred = self.linear(x)\n        return y_pred\n \nmodel = torch.nn.Linear(1 , 1)\n \n# defining loss function and optimizer\nloss_fn = torch.nn.L1Loss()\noptimizer = torch.optim.Adam(model.parameters(), lr = 0.01 )\n \nfor epoch in range(1000):\n    \n    # predicting y using initial weights\n    y_pred = model(X.requires_grad_())\n \n    # loss calculation\n    loss = loss_fn(y_pred, y)\n \n    # calculating gradients\n    loss.backward()\n \n    # updating weights\n    optimizer.step()\n \n    optimizer.zero_grad()\n \n# testing on new data    \nX = torch.Tensor([[7], [8]])\npredicted = model(X)\nprint(predicted)\n"], "Given a linked list A, swap every two adjacent nodes and return its head. NOTE: Your algorithm should use only constant space. You may not modify the values in the list; only nodes themselves can be changed. Problem Constraints 1 <= |A| <= 106 Input Format The first and the only argument of input contains a pointer to the head of the given linked list. Output Format Return a pointer to the head of the modified linked list. Example Input Input 1: A = 1 -> 2 -> 3 -> 4 Input 2: A = 7 -> 2 -> 1 Example Output Output 1: 2 -> 1 -> 4 -> 3 Output 2: 2 -> 7 -> 1 Example Explanation Explanation 1: In the first example (1, 2) and (3, 4) are the adjacent nodes. Swapping them will result in 2 -> 1 -> 4 -> 3 Explanation 2: In the second example, 3rd element i.e. 1 does not have an adjacent node, so it won't be swapped.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def swapPairs(self, A):\n        # Check if the linked list is empty or\n        # only has a single element.\n        if A==None:\n            return None\n        elif A.next==None:\n            return A\n        \n        # Keep changing the pointers of pairs\n        # while traversing the linked list.\n        head = A\n        head = head.next\n        prev = head\n        while A!=None:\n            if A.next==None:\n                break\n            temp = A.next\n            A.next = A.next.next\n            temp.next = A\n            if prev!=head:\n                prev.next = temp\n            prev = A\n            A = A.next\n        \n        return head\n\n\n\n", "Prototype Design Pattern - GeeksforGeeks": [], "Iterator Pattern - GeeksforGeeks": [], "Given a list, rotate the list to the right by k places, where k is non-negative. Problem Constraints 1 <= B <= 109 Input Format The first argument is ListNode A, pointing to the head of the list. The second argument is an integer B, representing the value of k. Output Format Return the rotated list. Example Input A = 1->2->3->4->5->NULL B = 2 Example Output 4->5->1->2->3->NULL Example Explanation Given list: A = 1->2->3->4->5->NULL Given B = 2; After rotating A once, A = 5->1->2->3->4->NULL After rotating A again, A = 4->5->1->2->3->NULL Hence after rotating the given list A, for B = 2, return 4->5->1->2->3->NULL": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : integer\n    # @return the head node in the linked list\n    def rotateRight(self, A, B):\n        head = A\n        last = None\n        length = 0\n        \n        # get length of list as well as the last node of the current list\n        while A:\n            last = A\n            A = A.next\n            length += 1\n        \n        # because B can be greater than length of list...normalize B\n        B %= length\n        \n        if B == 0:\n            return head\n        \n        cur = head\n        \n        # get to the point where you will detach the list and rotate it\n        for i in range(length - B - 1):\n            cur = cur.next\n        \n        rotated_head = cur.next\n        cur.next = None\n        last.next = head\n        \n        return rotated_head\n\n\n\n", "Learn Data Structures with Javascript | DSA Tutorial - GeeksforGeeks": [], "JavaScript Cheat Sheet - A Basic Guide to JavaScript - GeeksforGeeks": [], "CSS Cheat Sheet - A Basic Guide to CSS - GeeksforGeeks": [], "HTML Cheat Sheet - A Basic Guide to HTML - GeeksforGeeks": [], "Given a singly linked list L: L0 \u2192 L1 \u2192 \u2026 \u2192 Ln-1 \u2192 Ln, reorder it to: L0 \u2192 Ln \u2192 L1 \u2192 Ln-1 \u2192 L2 \u2192 Ln-2 \u2192 \u2026 You must do this in-place without altering the nodes\u2019 values. For example, Given {1,2,3,4}, reorder it to {1,4,2,3}.": "# Definition for singly-linked list.\n# class ListNode:\n#\tdef __init__(self, x):\n#\t\tself.val = x\n#\t\tself.next = None\n\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def reorderList(self, head):\n        \"\"\" Modifies input linked list in-place. Returns head of a new list.\n        Time complexity: O(n). Space complexity: O(1), n is len(linked list).\n        \"\"\"\n        # modifiy the list only if it has more than one node\n        if not head or not head.next:\n            return head\n            \n        # find the middle of the list using slow and fast pointers algorithm\n        prev = None  # last node of the left half of the list\n        slow = fast = head\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        prev.next = None  # detach left half of the list from the right half\n        # reverse right half of the list\n        prev = None\n        curr = slow  # slow is the start of the right half\n        while curr:\n            link = curr.next\n            curr.next = prev\n            prev = curr\n            curr = link\n        # prev now points to the head of reversed right half\n        # combine left and right half, attach it to dummy node\n        dummy = ListNode(None)\n        tail = dummy  # current tail of a new list\n        while head:  # left list is always gonna be shorter\n            link = head.next  # save link to the next node in the left list\n            head.next = prev\n            tail.next = head  # attach connected 2 nodes to the tail\n            tail = prev  # update tail\n            head = link  # move to the next node in left list\n            prev = prev.next\n        # if the length of the original list was odd, right half is gonna have\n        # 1 node more than the left half\n        if prev:\n            tail.next = prev\n        return dummy.next  # return new head\n\n\n\n", "jQuery Cheat Sheet \u2013 A Basic Guide to jQuery - GeeksforGeeks": [], "Angular Cheat Sheet - A Basic Guide to Angular - GeeksforGeeks": [], "Sort a linked list in O(n log n) time using constant space complexity. Example : Input : 1 -> 5 -> 4 -> 3 Returned list : 1 -> 3 -> 4 -> 5": "# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x, next):\n        self.val = x\n        self.next = next\n        \n        \ndef merge(left, right):\n    head = current = ListNode(None, None)\n    \n    curr_left, curr_right = left, right\n    while curr_left and curr_right:\n        if curr_left.val < curr_right.val:\n            current.next = curr_left\n            curr_left = curr_left.next\n        else:\n            current.next = curr_right\n            curr_right = curr_right.next\n        current = current.next\n            \n    if not curr_left:\n        current.next = curr_right\n    else:\n        current.next = curr_left\n    \n    return head.next\n\n    \nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def sortList(self, A):\n        slow = fast = A\n        \n        # Base case\n        if not A or not A.next:\n            return A\n            \n        if not A.next.next:\n            left, right = A, A.next\n            A.next = None\n            return merge(left, right)\n            \n        # Find mid\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow\n        \n        # Divide into two and sort each segment\n        right = self.sortList(mid.next)\n        mid.next = None\n        left = self.sortList(A)\n        \n        return merge(left, right)\n        \n            \n        \n\n\n", "Fabric.js - GeeksforGeeks": [], "D3.js - GeeksforGeeks": [], "Spectre CSS - GeeksforGeeks": [], "Bootstrap Cheatsheet - A Basic Guide to Bootstrap - GeeksforGeeks": [], "Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example, Given 1->2->3->3->4->4->5, return 1->2->5. Given 1->1->1->2->3, return 2->3.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def deleteDuplicates(self, A):\n        self.head = A\n        dummy_node = ListNode(0)\n        dummy_node.next = self.head\n        prev = dummy_node\n        curr = self.head\n        while curr is not None:\n            if curr.next is not None and curr.val == curr.next.val:\n                while curr.next is not None and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = prev.next\n            curr = curr.next\n        return dummy_node.next\n\n\n", "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists, and should also be sorted. For example, given following linked lists : 5 -> 8 -> 20 4 -> 11 -> 15 The merged list should be : 4 -> 5 -> 8 -> 11 -> 15 -> 20": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : head node of linked list\n    # @return the head node in the linked list\n    def mergeTwoLists(self, A, B):\n        head = None\n        if A.val > B.val:\n            head = B\n            B = B.next\n            if B == None:\n                head.next=A\n                return head \n        else:\n            head = A\n            A = A.next\n            if A==None:\n                head.next=B\n                return head\n\n        current = head\n        while True:\n            if A.val > B.val:\n                current.next = B\n                current = current.next\n                B = B.next\n                if B == None:\n                    current.next = A\n                    break\n            else:\n                current.next = A\n                current = current.next\n                A = A.next\n                if A == None:\n                    current.next = B\n                    break\n        return head\n\n\n\n\n", "Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1->1->2, return 1->2. Given 1->1->2->3->3, return 1->2->3.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    def deleteDuplicates(self, A):\n        node = A\n        while node and node.next:\n            while node.next and node.val == node.next.val:\n                node.next = node.next.next\n            node = node.next\n        return A\n\n\n", "You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 342 + 465 = 807 Make sure there are no trailing zeros in the output list So, 7 -> 0 -> 8 -> 0 is not a valid response even though the value is still 807.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : head node of linked list\n    # @return the head node in the linked list\n    def addTwoNumbers(self, A, B):\n        dummy = ListNode(0)\n        a, b, c = A, B, dummy\n        carry = False\n        while a or b or carry:\n            total = int(carry)\n            if a:\n                total += a.val\n                a = a.next\n            if b:\n                total += b.val\n                b = b.next\n            \n            if total >= 10:\n                carry = True\n                total %= 10\n            else:\n                carry = False\n            new = ListNode(total)\n            c.next = new\n            c = new\n        \n        return dummy.next\n\n\n", "Given a linked list A, remove the B-th node from the end of the list and return its head. For example, Given linked list: 1->2->3->4->5, and B = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. NOTE: If B is greater than the size of the list, remove the first node of the list. NOTE: Try doing it using constant additional space. Problem Constraints 1 <= |A| <= 106 Input Format The first argument of input contains a pointer to the head of the linked list. The second argument of input contains the integer B. Output Format Return the head of the linked list after deleting the B-th element from the end. Example Input Input 1: A = [1, 2, 3, 4, 5] B = 2 Input 2: A = [1] B = 1 Example Output Output 1: [1, 2, 3, 5] Output 2: [] Example Explanation Explanation 1: In the first example, 4 is the second last element. Explanation 2: In the second example, 1 is the first and the last element.": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @param B : integer\n    # @return the head node in the linked list\n    def removeNthFromEnd(self, A, B):\n        length = 0\n        cur = A\n        while cur:     ##calculating the length of the list\n            length += 1\n            cur = cur.next\n        if B >= length:    ## if this is the case deleting the head node of the list\n            return A.next\n        n = length - B    ## calucalting the node to be removed from listhead (node index starts with 'zero')\n        count = 0\n        prev = None\n        cur = A\n        while count < n:\n            prev = cur\n            cur = cur.next\n            count += 1\n        if cur.next is not None:    ## cur is the node required to be removed\n            prev.next = cur.next    ## removing the cur node from list by linking the prev node directly to next of the cur node\n        else:\n            prev.next = None\n        return A \n        \n\n\n\n", "Given a linked list A and a value B, partition it such that all nodes less than B come before nodes greater than or equal to B. You should preserve the original relative order of the nodes in each of the two partitions. Problem Constraints 1 <= |A| <= 106 1 <= A[i], B <= 109 Input Format The first argument of input contains a pointer to the head to the given linked list. The second argument of input contains an integer, B. Output Format Return a pointer to the head of the modified linked list. Example Input Input 1: A = [1, 4, 3, 2, 5, 2] B = 3 Input 2: A = [1, 2, 3, 1, 3] B = 2 Example Output Output 1: [1, 2, 2, 4, 3, 5] Output 2: [1, 1, 2, 3, 3] Example Explanation Explanation 1: [1, 2, 2] are less than B wheread [4, 3, 5] are greater than or equal to B. Explanation 2: [1, 1] are less than B wheread [2, 3, 3] are greater than or equal to B.": "class Solution:\n    # @param {ListNode} head\n    # @param {integer} x\n    # @return {ListNode}\n    def partition(self, head, x):\n        if not head:\n            return None\n\n        less, greaterEqual = ListNode(0), ListNode(0)\n        tempLess, tempGreaterEqual, temp = less, greaterEqual, head\n        while temp:\n            if temp.val < x:\n                tempLess.next = temp\n                tempLess = tempLess.next\n            else:\n                tempGreaterEqual.next = temp\n                tempGreaterEqual = tempGreaterEqual.next\n\n            cur = temp\n            temp = temp.next\n            cur.next = None\n\n        tempLess.next = greaterEqual.next\n        return less.next", "Sort a linked list using insertion sort. We have explained Insertion Sort at Slide 7 of Arrays ( http://www.interviewbit.com/courses/programming/topics/arrays/ ) Insertion Sort Wiki ( http://en.wikipedia.org/wiki/Insertion_sort#Algorithm ) has some details on Insertion Sort as well. Example : Input : 1 -> 3 -> 2 Return 1 -> 2 -> 3": "# Definition for singly-linked list.\n# class ListNode:\n#    def __init__(self, x):\n#        self.val = x\n#        self.next = None\n\nclass Solution:\n    # @param A : head node of linked list\n    # @return the head node in the linked list\n    \n    def insert(self, a, b):\n        pb, cb = b, b\n        while cb and cb.val < a.val:\n            pb = cb\n            cb = cb.next\n        pb.next = a\n        pb.next.next = cb\n    \n    def insertionSortList(self, A):\n        a, b = A, ListNode(0)\n        \n        while a:\n            temp = a.next\n            self.insert(a, b)\n            a = temp\n        return b.next\n        \n\n\n"}